{
  
    
        "post0": {
            "title": "seaborn_and_matplotlib",
            "content": "Tools - matplotlib . matplotlib 라이브러리를 사용하여 그래프를 그리는 방법 . pyplot은 pandas 같은 라이브러리와 함께 사용하며 그래프를 빠르게 그려보기 좋습니다. 그러나 코드의 가독성과 섬세한 제어는 object oriented API(객체지향 인터페이스)방식이 더 유리하게 느껴집니다. | pyplot과 object oriented API의 차이에 대해 상세히 알고 싶으시면 이 글을 참고하십시오 | . &#44592;&#48376; &#44536;&#47000;&#54532; . 우선은 matplotlib 라이브러리를 임포트 해줘야 합니다. . import matplotlib . %matplotlib inline . import matplotlib.pyplot as plt plt.plot([1, 2, 4, 9, 5, 3]) plt.show() . 같은 그림을 object oriented API를 이용해 그려보겠습니다. . fig, ax = plt.subplots() # 2. ax 위에 그래프를 그립니다. ax.plot([1, 2, 4, 9, 5, 3]) # 3. 그래프를 화면에 출력합니다. plt.show() . pyplot과 동일한 형태의 그래프가 그려집니다. | fig, ax를 선언하느라 한 줄을 더 입력해야 한다는 불편함이 있지만 ax 객체가 있어 그래프를 제어하기 더 쉬워집니다. | 많은 경우 fig, ax = plt.subplots() 대신 ax = plt.subplot()으로 해도 됩니다. | . plt.plot([-3, -2, 5, 0], [1, 6, 4, 3]) plt.show() . fig, ax = plt.subplots() ax.plot([-3, -2, 5, 0], [1, 6, 4, 3]) plt.show() . 수학적인 함수를 그려보겠습니다. NumPy의 linespace 함수를 사용하여 -2 ~ 2 범위에 속하는 500개의 부동소수로 구성된 x 배열을 생성합니다. 그 다음 x의 각 값의 거듭제곱된 값을 포함하는 y 배열을 생성합니다 . import numpy as np x = np.linspace(-2, 2, 500) y = x**2 plt.plot(x, y) plt.show() . fig, ax = plt.subplots() ax.plot(x, y) plt.show() . 타이틀과 x 및 y축에 대한 라벨, 그리고 모눈자를 추가적으로 그려보겠습니다. . plt.plot(x, y) plt.title(&quot;Square function&quot;) plt.xlabel(&quot;x&quot;) plt.ylabel(&quot;y = x**2&quot;) plt.grid(True)# 가로축세로축 그리기 plt.show() . fig, ax = plt.subplots() ax.plot(x, y) ax.set_title(&quot;Square function&quot;) ax.set_xlabel(&quot;x&quot;) ax.set_ylabel(&quot;y = x**2&quot;) ax.grid(True) plt.show() . &#49440;&#51032; &#49828;&#53440;&#51068;&#44284; &#49353;&#49345; . plt.plot([0, 100, 100, 0, 0, 100, 50, 0, 100], [0, 0, 100, 100, 0, 100, 130, 100, 0]) plt.axis([-10, 110, -10, 140]) plt.show() . fig, ax = plt.subplots() ax.plot([0, 100, 100, 0, 0, 100, 50, 0, 100], [0, 0, 100, 100, 0, 100, 130, 100, 0]) ax.set_xlim(-10, 110) ax.set_ylim(-10, 140) # set_xlim, set_ylim을 사용해서 명시하는 것이 더 체계적으로 느껴집니다. plt.show() . # &quot;g--&quot;는 &quot;초록색 파선&quot; # - 이 하나면 실선, -- 이면 점선 plt.plot([0, 100, 100, 0, 0], [0, 0, 100, 100, 0], &quot;r-&quot;, [0, 100, 50, 0, 100], [0, 100, 130, 100, 0], &quot;g--&quot;) plt.axis([-10, 110, -10, 140]) plt.show() . fig, ax = plt.subplots() ax.plot([0, 100, 100, 0, 0], [0, 0, 100, 100, 0], &quot;r-&quot;, [0, 100, 50, 0, 100], [0, 100, 130, 100, 0], &quot;g--&quot;) ax.set_xlim(-10, 110) ax.set_ylim(-10, 140) plt.show() . show를 호출하기 전 plot을 여러번 호출해도 가능합니다. . plt.plot([0, 100, 100, 0, 0], [0, 0, 100, 100, 0], &quot;r-&quot;) plt.plot([0, 100, 50, 0, 100], [0, 100, 130, 100, 0], &quot;g--&quot;) plt.axis([-10, 110, -10, 140]) plt.show() . fig, ax = plt.subplots() ax.plot([0, 100, 100, 0, 0], [0, 0, 100, 100, 0], &quot;r-&quot;) ax.plot([0, 100, 50, 0, 100], [0, 100, 130, 100, 0], &quot;g--&quot;) ax.set_xlim(-10, 110) ax.set_ylim(-10, 140) plt.show() . 선 대신에 간단한 점을 그려보는 것도 가능합니다. 아래는 초록색 파선, 빨강 점선, 파랑 삼각형의 예를 보여줍니다 . x = np.linspace(-1.4, 1.4, 30) plt.plot(x, x, &#39;g--&#39;, x, x**2, &#39;r:&#39;, x, x**3, &#39;b^&#39;) plt.show() . fig, ax = plt.subplots() x = np.linspace(-1.4, 1.4, 30) ax.plot(x, x, &#39;g--&#39;) ax.plot(x, x**2, &#39;r:&#39;) ax.plot(x, x**3, &#39;b^&#39;) # 여러 그래프를 ax.plot(x, x, &#39;g--&#39;, x, x**2, &#39;r:&#39;, x, x**3, &#39;b^&#39;)과 같이 한 줄에 그릴 수도 있습니다. # 그러나 이와 같이 따로 떼서 그리면 혼동을 방지할 수 있습니다. # 이는 pyplot도 마찬가지입니다. plt.show() . plot 함수는 Line2D객체로 구성된 리스트를 반환합니다. 이 선들에 대한 추가적인 속성을 설정할 수도 있습니다. 가령 선의 두께, 스타일, 투명도 같은것의 설정이 가능합니다. . x = np.linspace(-1.4, 1.4, 30) line1, line2, line3 = plt.plot(x, x, &#39;g--&#39;, x, x**2, &#39;r:&#39;, x, x**3, &#39;b^&#39;) line1.set_linewidth(3.0) line1.set_dash_capstyle(&quot;round&quot;) line3.set_alpha(0.2) plt.show() . x = np.linspace(-1.4, 1.4, 30) fig, ax = plt.subplots() # plot을 나누어 그리면 어디에 어떤 설정이 적용되었는지 알아보기 편합니다. # linewidth, alpha와 같은 line style도 plot() 안에 넣으면 혼동을 방지할 수 있습니다. line1 = ax.plot(x, x, &#39;g--&#39;, linewidth=3, dash_capstyle=&#39;round&#39;) line2 = ax.plot(x, x**2, &#39;r:&#39;) line3 = ax.plot(x, x**3, &#39;b^&#39;, alpha=0.2) plt.show() . &#44536;&#47548; &#51200;&#51109; . 파일이름을 지정하여 savefig 함수를 호출해 주면 됩니다. 가능한 이미지 포맷은 사용하는 그래픽 백엔드에 따라서 지원 여부가 결정됩니다. . x = np.linspace(-1.4, 1.4, 30) plt.plot(x, x**2) plt.savefig(&quot;my_square_function.png&quot;, transparent=True) . &#48512;&#48516; &#44536;&#47000;&#54532; (subplot) . matplotlib는 하나의 그림(figure)에 여러개의 부분 그래프를 포함할 수 있습니다. 이 부분 그래프는 격자 형식으로 관리됩니다. subplot 함수를 호출하여 부분 그래프를 생성할 수 있습니다. 이 때 격자의 행/열의 수 및 그래프를 그리고자 하는 부분 그래프의 색인을 파라미터로서 지정해줄 수 있습니다 (색인은 1부터 시작하며, 좌-&gt;우, 상단-&gt;하단의 방향입니다). . pyplot은 현재 활성화된 부분 그래프를 계속해서 추적합니다 (plt.gca()를 호출하여 해당 부분 그래프의 참조를 얻을 수 있습니다). 따라서, plot 함수를 호출할 때 활성화된 부분 그래프에 그림이 그려지게 됩니다. | . x = np.linspace(-1.4, 1.4, 30) # subplot(2,2,1)은 subplot(221)로 축약할 수 있습니다. plt.subplot(2, 2, 1) # 2 행 2 열 크기의 격자 중 첫 번째 부분 그래프 = 좌측 상단 plt.plot(x, x) plt.subplot(2, 2, 2) # 2 행 2 열 크기의 격자 중 두 번째 부분 그래프 = 우측 상단 plt.plot(x, x**2) plt.subplot(2, 2, 3) # 2 행 2 열 크기의 격자 중 세 번째 부분 그래프 = 좌측 하단 plt.plot(x, x**3) plt.subplot(2, 2, 4) # 2 행 2 열 크기의 격자 중 네 번째 부분 그래프 = 우측 하단 plt.plot(x, x**4) plt.show() . x = np.linspace(-1.4, 1.4, 30) fig, ax = plt.subplots(2, 2) # 순서대로 row의 갯수, col의 갯수입니다. nrows=2, cols=2로 지정할 수도 있습니다. # plot위치는 ax[row, col] 또는 ax[row][col]로 지정합니다. ax[0, 0].plot(x, x) # 2 행 2 열 크기의 격자 중 첫 번째 부분 그래프 = 좌측 상단 ax[0, 1].plot(x, x**2) # 2 행 2 열 크기의 격자 중 두 번째 부분 그래프 = 우측 상단 ax[1, 0].plot(x, x**3) # 2 행 2 열 크기의 격자 중 세 번째 부분 그래프 = 좌측 하단 ax[1, 1].plot(x, x**4) # 2 행 2 열 크기의 격자 중 네 번째 부분 그래프 = 우측 하단 plt.show() . 격자의 여러 영역으로 확장된 부분 그래프를 생성하겠습니다. . plt.subplot(2, 2, 1) # 2 행 2 열 크기의 격자 중 첫 번째 부분 그래프 = 좌측 상단 plt.plot(x, x) plt.subplot(2, 2, 2) # 2 행 2 열 크기의 격자 중 두 번째 부분 그래프 = 우측 상단 plt.plot(x, x**2) plt.subplot(2, 1, 2) # 2행 *1* 열의 두 번째 부분 그래프 = 하단 # 2행 1열 크기의 그래프가 두 개 그려질 수 있지만, # 상단 부분은 이미 두 개의 부분 그래프가 차지하였다. # 따라서, 두 번째 부분 그래프로 지정함 plt.plot(x, x**3) plt.show() . grid = plt.GridSpec(2, 2) # 2행 2열 크기의 격자를 준비합니다. ax1 = plt.subplot(grid[0, 0]) # 2행 2열 크기의 격자 중 첫 번째 부분 그래프 = 좌측 상단 ax2 = plt.subplot(grid[0, 1]) # 2행 2열 크기의 격자 중 두 번째 부분 그래프 = 우측 상단 ax3 = plt.subplot(grid[1, 0:]) # 2행 *1*열의 두 번째 부분 그래프 = 하단 # 범위를 [1, 0:]으로 설정하여 2행 전체를 지정함. ax1.plot(x, x) ax2.plot(x, x**2) ax3.plot(x, x**3) plt.show() . 보다 복잡한 부분 그래프의 위치 선정이 필요하다면, subplot2grid를 대신 사용할 수 있습니다. 격자의 행과 열의 번호 및 격자에서 해당 부분 그래프를 그릴 위치를 지정해줄 수 있습니다 (좌측상단 = (0,0). 또한 몇 개의 행/열로 확장되어야 하는지도 추가적으로 지정할 수 있습니다. 아래는 그에 대한 예를 보여줍니다 . plt.subplot2grid((3,3), (0, 0), rowspan=2, colspan=2) plt.plot(x, x**2) plt.subplot2grid((3,3), (0, 2)) plt.plot(x, x**3) plt.subplot2grid((3,3), (1, 2), rowspan=2) plt.plot(x, x**4) plt.subplot2grid((3,3), (2, 0), colspan=2) plt.plot(x, x**5) plt.show() . gridsize = (3, 3) # 2행 2열 크기의 격자를 준비합니다. ax1 = plt.subplot2grid(gridsize, (0,0), rowspan=2, colspan=2) ax2 = plt.subplot2grid(gridsize, (0,2)) ax3 = plt.subplot2grid(gridsize, (1,2), rowspan=2) ax4 = plt.subplot2grid(gridsize, (2,0), colspan=2) ax1.plot(x, x**2) ax2.plot(x, x**3) ax3.plot(x, x**4) ax4.plot(x, x**5) plt.show() . &#50668;&#47084;&#44060;&#51032; &#44536;&#47548; (figure) . 여러개의 그림을 그리는것도 가능합니다. 각 그림은 하나 이상의 부분 그래프를 가질 수 있습니다. 기본적으로는 matplotlib이 자동으로 figure(1)을 생성합니다. 그림간 전환을 할 때, pyplot은 현재 활성화된 그림을 계속해서 추적합니다 (이에대한 참조는 plt.gcf()의 호출로 알 수 있습니다). 또한 활성화된 그림의 활성화된 부분 그래프가 현재 그래프가 그려질 부분 그래프가 됩니다. . x = np.linspace(-1.4, 1.4, 30) plt.figure(1) plt.subplot(211) plt.plot(x, x**2) plt.title(&quot;Square and Cube&quot;) plt.subplot(212) plt.plot(x, x**3) plt.figure(2, figsize=(10, 5)) plt.subplot(121) plt.plot(x, x**4) plt.title(&quot;y = x**4&quot;) plt.subplot(122) plt.plot(x, x**5) plt.title(&quot;y = x**5&quot;) plt.figure(1) # 그림 1로 돌아가며, 활성화된 부분 그래프는 212 (하단)이 됩니다 plt.plot(x, -x**3, &quot;r:&quot;) plt.show() . x = np.linspace(-1.4, 1.4, 30) fig1, ax1 = plt.subplots(nrows=2, ncols=1) ax1[0].plot(x, x**2) ax1[0].set_title(&quot;Square and Cube&quot;) ax1[1].plot(x, x**3) fig2, ax2 = plt.subplots(nrows=1, ncols=2, figsize=(10, 5)) ax2[0].plot(x, x**4) ax2[0].set_title(&quot;y = x**4&quot;) ax2[1].plot(x, x**5) ax2[1].set_title(&quot;y = x**5&quot;) ax1[1].plot(x, -x**3, &quot;r:&quot;) # 그림 1로 돌아가며, 활성화된 부분 그래프는 ax1[1] (하단)이 됩니다. plt.show() . Pyplot&#51032; &#49345;&#53468; &#47672;&#49888;: &#50516;&#49884;&#51201; vs &#47749;&#49884;&#51201; . 지금까지 현재의 활성화된 부분 그래프를 추적하는 Pyplot의 상태 머신을 사용했었습니다. plot 함수를 호출할 때마다 pyplot은 단지 현재 활성화된 부분 그래프에 그림을 그립니다. 그리고 plot 함수를 호출 할 때, 그림 및 부분 그래프가 아직 존재하지 않는다면 이들을 만들어내는 작업도 일부 수행합니다. 이는 주피터와 같은 대화식의 환경에서 편리합니다. . 그러나 프로그램을 작성하는 것이라면, 명시적인 것이 암시적인것 보다 더 낫습니다. 명시적인 코드는 일반적으로 디버깅과 유지보수가 더 쉽습니다. 이 말에 동의하지 않는다면, Python 젠(Zen)의 두 번째 규칙을 읽어보시기 바랍니다. . import this . The Zen of Python, by Tim Peters Beautiful is better than ugly. Explicit is better than implicit. Simple is better than complex. Complex is better than complicated. Flat is better than nested. Sparse is better than dense. Readability counts. Special cases aren&#39;t special enough to break the rules. Although practicality beats purity. Errors should never pass silently. Unless explicitly silenced. In the face of ambiguity, refuse the temptation to guess. There should be one-- and preferably only one --obvious way to do it. Although that way may not be obvious at first unless you&#39;re Dutch. Now is better than never. Although never is often better than *right* now. If the implementation is hard to explain, it&#39;s a bad idea. If the implementation is easy to explain, it may be a good idea. Namespaces are one honking great idea -- let&#39;s do more of those! . Pyplot은 상태 머신을 완전히 무시할 수 있게끔 해 줍니다. 따라서 아름다운 명시적 코드를 작성하는것이 가능하죠. 간단히 subplots 함수를 호출해서 반환되는 figure 객체 및 축의 리스트를 사용하면 됩니다. . 다음은 matplotlib의 object oriented API(객체지향 인터페이스)입니다 . x = np.linspace(-2, 2, 200) fig1, (ax_top, ax_bottom) = plt.subplots(2, 1, sharex=True) fig1.set_size_inches(10,5) line1, line2 = ax_top.plot(x, np.sin(3*x**2), &quot;r-&quot;, x, np.cos(5*x**2), &quot;b-&quot;) line3, = ax_bottom.plot(x, np.sin(3*x), &quot;r-&quot;) ax_top.grid(True) fig2, ax = plt.subplots(1, 1) ax.plot(x, x**2) plt.show() . Pylab vs Pyplot vs Matplotlib . matplotlib은 완전한 라이브러리이며, pylab 및 pyplot을 포함한 모든것을 가지고 있습니다. . Pyplot은 그래프를 그리기위한 다양한 도구를 제공합니다. 여기에는 내부적인 객체지향적인 그래프 그리기 라이브러리에 대한 상태 머신 인터페이스도 포함됩니다. . Pylab은 mkatplotlib.pyplot 및 NumPy를 단일 네임스페이스로 임포트하는 편리성을 위한 모듈입니다. 인터넷에 떠도는 pylab을 사용하는 여러 예제를 보게 될 것입니다. 그러나 이는 더이상 권장되는 사용방법은 아닙니다. 왜냐하면 명시적인 임포트가 암시적인것 보다 더 낫기 때문입니다. . &#53581;&#49828;&#53944; &#44536;&#47532;&#44592; . text 함수를 호출하여 텍스트를 그래프의 원하는 위치에 추가할 수 있습니다. 출력을 원하는 텍스트와 수평 및 수직 좌표를 지정하고, 추가적으로 몇 가지 속성을 지정해 주기만 하면 됩니다. matplotlib의 모든 텍스트는 TeX 방정식 표현을 포함할 수 있습니다. . x = np.linspace(-1.5, 1.5, 30) px = 0.8 py = px**2 plt.plot(x, x**2, &quot;b-&quot;, px, py, &quot;ro&quot;) plt.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;blue&#39;, horizontalalignment=&quot;center&quot;) plt.text(px - 0.08, py, &quot;Beautiful point&quot;, ha=&quot;right&quot;, weight=&quot;heavy&quot;) plt.text(px, py, &quot;x = %0.2f ny = %0.2f&quot;%(px, py), rotation=50, color=&#39;gray&#39;) plt.show() . fig, ax = plt.subplots() ax.plot(x, x**2, &quot;b-&quot;) ax.plot(px, py, &quot;ro&quot;) ax.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;blue&#39;, horizontalalignment=&quot;center&quot;) ax.text(px - 0.08, py, &quot;Beautiful point&quot;, ha=&quot;right&quot;, weight=&quot;heavy&quot;) ax.text(px, py, &quot;x = %0.2f ny = %0.2f&quot;%(px, py), rotation=50, color=&#39;gray&#39;) plt.show() . 아래 그래프의 &quot;beautiful point&quot; 같은 텍스트 처럼, 그래프의 요소에 주석을 다는것은 꽤 흔한 일입니다. annotate 함수는 이를 쉽게 할 수 있게 해 줍니다: 관심있는 부분의 위치를 지정하고, 텍스트의 위치를 지정합니다. 그리고 텍스트 및 화살표에 대한 추가적인 속성도 지정해줄 수 있습니다. . plt.plot(x, x**2, px, py, &quot;ro&quot;) plt.annotate(&quot;Beautiful point&quot;, xy=(px, py), xytext=(px-1.3,py+0.5), color=&quot;green&quot;, weight=&quot;heavy&quot;, fontsize=14, arrowprops={&quot;facecolor&quot;: &quot;lightgreen&quot;}) plt.show() . fig, ax = plt.subplots() ax.plot(x, x**2, px, py, &quot;ro&quot;) ax.annotate(&quot;Beautiful point&quot;, xy=(px, py), xytext=(px-1.3,py+0.5), color=&quot;green&quot;, weight=&quot;heavy&quot;, fontsize=14, arrowprops={&quot;facecolor&quot;: &quot;lightgreen&quot;}) plt.show() . bbox 속성을 사용하면, 텍스트를 포함하는 사각형을 그려볼 수도 있습니다. . plt.plot(x, x**2, px, py, &quot;ro&quot;) bbox_props = dict(boxstyle=&quot;rarrow,pad=0.3&quot;, ec=&quot;b&quot;, lw=2, fc=&quot;lightblue&quot;) plt.text(px-0.2, py, &quot;Beautiful point&quot;, bbox=bbox_props, ha=&quot;right&quot;) bbox_props = dict(boxstyle=&quot;round4,pad=1,rounding_size=0.2&quot;, ec=&quot;black&quot;, fc=&quot;#EEEEFF&quot;, lw=5) plt.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;black&#39;, ha=&quot;center&quot;, bbox=bbox_props) plt.show() . fig, ax = plt.subplots() ax.plot(x, x**2) ax.plot(px, py, &quot;ro&quot;) bbox_props = dict(boxstyle=&quot;rarrow,pad=0.3&quot;, ec=&quot;b&quot;, lw=2, fc=&quot;lightblue&quot;) ax.text(px-0.2, py, &quot;Beautiful point&quot;, bbox=bbox_props, ha=&quot;right&quot;) bbox_props = dict(boxstyle=&quot;round4,pad=1,rounding_size=0.2&quot;, ec=&quot;black&quot;, fc=&quot;#EEEEFF&quot;, lw=5) ax.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;black&#39;, ha=&quot;center&quot;, bbox=bbox_props) plt.show() . xkcd 스타일의 그래프를 그려보고 싶다면, with plt.xkcd() 섹션 블록을 활용할 수도 있습니다. . with plt.xkcd(): plt.plot(x, x**2, px, py, &quot;ro&quot;) bbox_props = dict(boxstyle=&quot;rarrow,pad=0.3&quot;, ec=&quot;b&quot;, lw=2, fc=&quot;lightblue&quot;) plt.text(px-0.2, py, &quot;Beautiful point&quot;, bbox=bbox_props, ha=&quot;right&quot;) bbox_props = dict(boxstyle=&quot;round4,pad=1,rounding_size=0.2&quot;, ec=&quot;black&quot;, fc=&quot;#EEEEFF&quot;, lw=5) plt.text(0, 1.5, &quot;Square function n$y = x^2$&quot;, fontsize=20, color=&#39;black&#39;, ha=&quot;center&quot;, bbox=bbox_props) plt.show() . &#48276;&#47168; (Legends) . 범례를 추가하는 가장 간단한 방법은 모든 선에 라벨을 설정 해 주고, legend 함수를 호출하는 것입니다. . x = np.linspace(-1.4, 1.4, 50) plt.plot(x, x**2, &quot;r--&quot;, label=&quot;Square function&quot;) plt.plot(x, x**3, &quot;g-&quot;, label=&quot;Cube function&quot;) plt.legend(loc=&quot;best&quot;) plt.grid(True) plt.show() . x = np.linspace(-1.4, 1.4, 50) fig, ax = plt.subplots() ax.plot(x, x**2, &quot;r--&quot;, label=&quot;Square function&quot;) ax.plot(x, x**3, &quot;g-&quot;, label=&quot;Cube function&quot;) ax.legend(loc=&quot;best&quot;) ax.grid(True) plt.show() . &#48708;&#49440;&#54805; &#52377;&#46020; . Matplotlib은 로그, 로짓(logit)과 같은 비선형 척도를 지원합니다. . x = np.linspace(0.1, 15, 500) y = x**3/np.exp(2*x) plt.figure(1) plt.plot(x, y) plt.yscale(&#39;linear&#39;) plt.title(&#39;linear&#39;) plt.grid(True) plt.figure(2) plt.plot(x, y) plt.yscale(&#39;log&#39;) plt.title(&#39;log&#39;) plt.grid(True) plt.figure(3) plt.plot(x, y) plt.yscale(&#39;logit&#39;) plt.title(&#39;logit&#39;) plt.grid(True) plt.figure(4) plt.plot(x, y - y.mean()) plt.yscale(&#39;symlog&#39;, linthreshy=0.05) plt.title(&#39;symlog&#39;) plt.grid(True) plt.show() . x = np.linspace(0.1, 15, 500) y = x**3/np.exp(2*x) fig1, ax1 = plt.subplots() ax1.plot(x, y) ax1.set_yscale(&#39;linear&#39;) ax1.set_title(&#39;linear&#39;) ax1.grid(True) fig2, ax2 = plt.subplots() ax2.plot(x, y) ax2.set_yscale(&#39;log&#39;) ax2.set_title(&#39;log&#39;) ax2.grid(True) fig3, ax3 = plt.subplots() ax3.plot(x, y) ax3.set_yscale(&#39;logit&#39;) ax3.set_title(&#39;logit&#39;) ax3.grid(True) fig4, ax4 = plt.subplots() ax4.plot(x, y - y.mean()) ax4.set_yscale(&#39;symlog&#39;, linthreshy=0.05) ax4.set_title(&#39;symlog&#39;) ax4.grid(True) plt.show() . &#54001;&#44284; &#54001;&#52964; (Ticks and tickers) . 각 축에는 &quot;틱(ticks)&quot;이라는 작은 표시가 있습니다. 정확히 말하자면, &quot;틱&quot;은 표시(예. (-1, 0, 1))의 위치&quot;이며, 틱 선은 그 위치에 그려지는 작은 선입니다. 또한 &quot;틱 라벨&quot;은 틱 선 옆에 그려지는 라벨이며, &quot;틱커&quot;는 틱의 위치를 결정하는 객체 입니다. 기본적인 틱커는 ~5 에서 8 틱을 위치시키는데 꽤 잘 작동합니다. 즉, 틱 서로간에 적당한 거리를 표현합니다. . 하지만, 가끔은 좀 더 이를 제어할 필요가 있습니다 (예. 위의 로짓 그래프에서는 너무 많은 틱 라벨이 있습니다). 다행히도 matplotlib은 틱을 완전히 제어하는 방법을 제공합니다. 심지어 보조 눈금(minor tick)을 활성화 할 수도 있습니다. . x = np.linspace(-2, 2, 100) plt.figure(1, figsize=(15,10)) plt.subplot(131) plt.plot(x, x**3) plt.grid(True) plt.title(&quot;Default ticks&quot;) ax = plt.subplot(132) plt.plot(x, x**3) ax.xaxis.set_ticks(np.arange(-2, 2, 1)) plt.grid(True) plt.title(&quot;Manual ticks on the x-axis&quot;) ax = plt.subplot(133) plt.plot(x, x**3) plt.minorticks_on() ax.tick_params(axis=&#39;x&#39;, which=&#39;minor&#39;, bottom=&#39;off&#39;) ax.xaxis.set_ticks([-2, 0, 1, 2]) ax.yaxis.set_ticks(np.arange(-5, 5, 1)) ax.yaxis.set_ticklabels([&quot;min&quot;, -4, -3, -2, -1, 0, 1, 2, 3, &quot;max&quot;]) plt.title(&quot;Manual ticks and tick labels n(plus minor ticks) on the y-axis&quot;) plt.grid(True) plt.show() . x = np.linspace(-2, 2, 100) fig, ax = plt.subplots(ncols=3, figsize=(15, 10)) ax[0].plot(x, x**3) ax[0].grid(True) ax[0].set_title(&quot;Default ticks&quot;) ax[1].plot(x, x**3) ax[1].grid(True) ax[1].set_xticks(np.arange(-2, 2, 1)) ax[1].set_title(&quot;Manual ticks on the x-axis&quot;) ax[2].plot(x, x**3) ax[2].grid(True) ax[2].minorticks_on() ax[2].set_xticks([-2, 0, 1, 2], minor=False) ax[2].set_yticks(np.arange(-5, 5, 1)) ax[2].set_yticklabels([&quot;min&quot;, -4, -3, -2, -1, 0, 1, 2, 3, &quot;max&quot;]) ax[2].set_title(&quot;Manual ticks and tick labels n(plus minor ticks) on the y-axis&quot;) plt.show() . &#44537;&#51340;&#54364;&#44228;&#51032; &#53804;&#50689; (Polar projection) . 극좌표계 그래프를 그리는 것은 매우 간단합니다. 부분 그래프를 생성할 때 projection 속성을 &quot;polar&quot;로 설정해 주기만 하면 됩니다. . projection을 사용할 때는 plt.figure()로 Figure 객체를 먼저 생성한 후 plt.subplot()이나 plt.add_subplot()으로 Axes 객체를 추가해 주거나, fig.subplots() 안에 subplot_kw=={&#39;polar&#39;:True}로 지정해 주어야 합니다. | . radius = 1 theta = np.linspace(0, 2*np.pi*radius, 1000) plt.subplot(111, projection=&#39;polar&#39;) plt.plot(theta, np.sin(5*theta), &quot;g-&quot;) plt.plot(theta, 0.5*np.cos(20*theta), &quot;b-&quot;) plt.show() . radius = 1 theta = np.linspace(0, 2*np.pi*radius, 1000) fig = plt.figure() ax = fig.add_subplot(projection=&#39;polar&#39;) # 또는, subplot_kw 를 이용해서 polar plot으로 설정합니다. # fig, ax = plt.subplots(subplot_kw={&#39;polar&#39;:True}) ax.plot(theta, np.sin(5*theta), &quot;g-&quot;) ax.plot(theta, 0.5*np.cos(20*theta), &quot;b-&quot;) plt.show() . 3&#52264;&#50896; &#53804;&#50689; . 3차원 그래프를 그리는것은 꽤 간단합니다. 우선 &quot;3d&quot; 투영을 등록하는 Axes3D를 임포트 해줘야 합니다. 그리곤 projection 속성을 &quot;3d&quot;로 설정된 부분 그래프 생성합니다. 그러면 Axes3DSubplot 이라는 객체가 반환되는데, 이 객체의 plot_surface 메서드를 호출하면 x, y, z 좌표를 포함한 추가적이나 속성을 지정할 수 있습니다. . from mpl_toolkits.mplot3d import Axes3D x = np.linspace(-5, 5, 50) y = np.linspace(-5, 5, 50) X, Y = np.meshgrid(x, y) R = np.sqrt(X**2 + Y**2) Z = np.sin(R) figure = plt.figure(1, figsize = (12, 4)) subplot3d = plt.subplot(111, projection=&#39;3d&#39;) # 이제현 주: Axes 객체입니다. surface = subplot3d.plot_surface(X, Y, Z, rstride=1, cstride=1, cmap=matplotlib.cm.coolwarm, linewidth=0.1) plt.show() . 동일한 데이터를 출력하는 또 다른 방법은 등고선도(contour plot)를 이용하는 것입니다. . plt.contourf(X, Y, Z, cmap=matplotlib.cm.coolwarm) plt.colorbar() plt.show() . fig, ax = plt.subplots() contour = ax.contourf(X, Y, Z, cmap=matplotlib.cm.coolwarm) plt.colorbar(contour) plt.show() . &#49328;&#51216;&#46020;(Scatter plot) . 각 점에 대한 x 및 y 좌표를 제공하면 산점도를 그릴 수 있습니다. . from numpy.random import rand x, y = rand(2, 100) plt.scatter(x, y) plt.show() . from numpy.random import rand x, y = rand(2, 100) fig, ax = plt.subplots() ax.scatter(x, y) plt.show() . 각 점의 크기를 정할 수도 있습니다. . x, y, scale = rand(3, 100) scale = 500 * scale ** 5 plt.scatter(x, y, s=scale) plt.show() . x, y, scale = rand(3, 100) scale = 500 * scale ** 5 fig, ax = plt.subplots() ax.scatter(x, y, s=scale) plt.show() . 테두리 및 모양의 내부 색상, 그리고 투명도 설정이 가능합니다. . for color in [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]: n = 100 x, y = rand(2, n) scale = 500.0 * rand(n) ** 5 plt.scatter(x, y, s=scale, c=color, alpha=0.3, edgecolors=&#39;blue&#39;) plt.grid(True) plt.show() . fig, ax = plt.subplots() for color in [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]: n = 100 x, y = rand(2, n) scale = 500.0 * rand(n) ** 5 ax.scatter(x, y, s=scale, c=color, alpha=0.3, edgecolors=&#39;blue&#39;) ax.grid(True) plt.show() . &#49440; . plot 함수를 사용하여 선을 그릴 수 있습니다. 하지만, 가끔은 그래프를 통과하는 무한한 선을 그리는 유틸리티 함수를 만들면 편리합니다 (기울기와 절편으로). 또한 hlines 및 vlines 함수를 사용하면, 아래와 같이 부분 수평 및 수직 선을 그릴 수도 있습니다: . from numpy.random import randn def plot_line(axis, slope, intercept, **kargs): xmin, xmax = axis.get_xlim() plt.plot([xmin, xmax], [xmin*slope+intercept, xmax*slope+intercept], **kargs) x = randn(1000) y = 0.5*x + 5 + randn(1000)*2 plt.axis([-2.5, 2.5, -5, 15]) plt.scatter(x, y, alpha=0.2) plt.plot(1, 0, &quot;ro&quot;) plt.vlines(1, -5, 0, color=&quot;red&quot;) plt.hlines(0, -2.5, 1, color=&quot;red&quot;) plot_line(axis=plt.gca(), slope=0.5, intercept=5, color=&quot;magenta&quot;) plt.grid(True) plt.show() . from numpy.random import randn # Axis를 인자로 전달하여 함수 연산과 시각화를 수행합니다. def plot_line(axis, slope, intercept, **kargs): xmin, xmax = axis.get_xlim() axis.plot([xmin, xmax], [xmin*slope+intercept, xmax*slope+intercept], **kargs) x = randn(1000) y = 0.5*x + 5 + randn(1000)*2 fig, ax = plt.subplots() ax.set_xlim(-2.5, 2.5) ax.set_ylim(-5, 15) ax.scatter(x, y, alpha=0.2) ax.plot(1, 0, &quot;ro&quot;) ax.vlines(1, -5, 0, color=&quot;red&quot;) ax.hlines(0, -2.5, 1, color=&quot;red&quot;) plot_line(axis=ax, slope=0.5, intercept=5, color=&quot;magenta&quot;) ax.grid(True) plt.show() . &#55176;&#49828;&#53664;&#44536;&#47016; . data = [1, 1.1, 1.8, 2, 2.1, 3.2, 3, 3, 3, 3] plt.subplot(211) plt.hist(data, bins = 10, rwidth=0.8) plt.subplot(212) plt.hist(data, bins = [1, 1.5, 2, 2.5, 3], rwidth=0.95) plt.xlabel(&quot;Value&quot;) plt.ylabel(&quot;Frequency&quot;) plt.show() . data = [1, 1.1, 1.8, 2, 2.1, 3.2, 3, 3, 3, 3] fig, ax = plt.subplots(2, 1) ax[0].hist(data, bins = 10, rwidth=0.8) ax[1].hist(data, bins = [1, 1.5, 2, 2.5, 3], rwidth=0.95) ax[1].set_xlabel(&quot;Value&quot;) ax[1].set_ylabel(&quot;Frequency&quot;) plt.show() . data1 = np.random.randn(400) data2 = np.random.randn(500) + 3 data3 = np.random.randn(450) + 6 data4a = np.random.randn(200) + 9 data4b = np.random.randn(100) + 10 plt.hist(data1, bins=5, color=&#39;g&#39;, alpha=0.75, label=&#39;bar hist&#39;) # default histtype=&#39;bar&#39; plt.hist(data2, color=&#39;b&#39;, alpha=0.65, histtype=&#39;stepfilled&#39;, label=&#39;stepfilled hist&#39;) plt.hist(data3, color=&#39;r&#39;, histtype=&#39;step&#39;, label=&#39;step hist&#39;) plt.hist((data4a, data4b), color=(&#39;r&#39;,&#39;m&#39;), alpha=0.55, histtype=&#39;barstacked&#39;, label=(&#39;barstacked a&#39;, &#39;barstacked b&#39;)) plt.xlabel(&quot;Value&quot;) plt.ylabel(&quot;Frequency&quot;) plt.legend() plt.grid(True) plt.show() . /usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray. return asarray(a).size /usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray. X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X)) . data1 = np.random.randn(400) data2 = np.random.randn(500) + 3 data3 = np.random.randn(450) + 6 data4a = np.random.randn(200) + 9 data4b = np.random.randn(100) + 10 fig, ax = plt.subplots() ax.hist(data1, bins=5, color=&#39;g&#39;, alpha=0.75, label=&#39;bar hist&#39;) # default histtype=&#39;bar&#39; ax.hist(data2, color=&#39;b&#39;, alpha=0.65, histtype=&#39;stepfilled&#39;, label=&#39;stepfilled hist&#39;) ax.hist(data3, color=&#39;r&#39;, histtype=&#39;step&#39;, label=&#39;step hist&#39;) ax.hist((data4a, data4b), color=(&#39;r&#39;,&#39;m&#39;), alpha=0.55, histtype=&#39;barstacked&#39;, label=(&#39;barstacked a&#39;, &#39;barstacked b&#39;)) ax.set_xlabel(&quot;Value&quot;) ax.set_ylabel(&quot;Frequency&quot;) ax.legend() ax.grid(True) plt.show() . /usr/local/lib/python3.7/dist-packages/numpy/core/fromnumeric.py:3208: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray. return asarray(a).size /usr/local/lib/python3.7/dist-packages/matplotlib/cbook/__init__.py:1376: VisibleDeprecationWarning: Creating an ndarray from ragged nested sequences (which is a list-or-tuple of lists-or-tuples-or ndarrays with different lengths or shapes) is deprecated. If you meant to do this, you must specify &#39;dtype=object&#39; when creating the ndarray. X = np.atleast_1d(X.T if isinstance(X, np.ndarray) else np.asarray(X)) . seaborn_and_matplotlib . 1.1 Load data . 예제로 사용할 펭귄 데이터를 불러옵니다. seaborn에 내장되어 있습니다. . import pandas as pd import matplotlib.pyplot as plt import seaborn as sns penguins = sns.load_dataset(&quot;penguins&quot;) penguins.head() . species island bill_length_mm bill_depth_mm flipper_length_mm body_mass_g sex . 0 Adelie | Torgersen | 39.1 | 18.7 | 181.0 | 3750.0 | Male | . 1 Adelie | Torgersen | 39.5 | 17.4 | 186.0 | 3800.0 | Female | . 2 Adelie | Torgersen | 40.3 | 18.0 | 195.0 | 3250.0 | Female | . 3 Adelie | Torgersen | NaN | NaN | NaN | NaN | NaN | . 4 Adelie | Torgersen | 36.7 | 19.3 | 193.0 | 3450.0 | Female | . &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;24px&quot;viewBox=&quot;0 0 24 24&quot; width=&quot;24px&quot;&gt; &lt;/svg&gt; 1.2 Figure and Axes . matplotlib으로 도화지figure를 깔고 축공간axes를 만듭니다. 1 x 2 축공간을 구성합니다. . fig, axes = plt.subplots(ncols=2, figsize=(8,4)) fig.tight_layout() . 1.3 plot with matplotlib . matplotlib 기능을 이용해서 산점도를 그립니다. . x축은 부리 길이 bill length | y축은 부리 위 아래 두께 bill depth | 색상은 종species로 합니다. 4.lie, Chinstrap, Gentoo이 있습니다. | 두 축공간 중 왼쪽에만 그립니다. . 컬러를 다르게 주기 위해 f-string 포맷을 사용했습니다. . fig, axes = plt.subplots(ncols=2,figsize=(8,4)) species_u = penguins[&quot;species&quot;].unique() for i, s in enumerate(species_u): axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C{i}&quot;, label=s, alpha=0.3) axes[0].legend(species_u, title=&quot;species&quot;) axes[0].set_xlabel(&quot;Bill Length (mm)&quot;) axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;) # plt.show() fig.tight_layout() . 조금 더 간단히 그리는 방법 matplotlib는 기본적으로 Categorical 변수를 color로 바로 사용하지 못함 . penguins[&quot;species_codes&quot;] = pd.Categorical(penguins[&quot;species&quot;]).codes fig, axes = plt.subplots(ncols=2,figsize=(8,4)) axes[0].scatter(data=penguins, x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, c=&quot;species_codes&quot;, alpha=0.3) . &lt;matplotlib.collections.PathCollection at 0x7ff640cf4c50&gt; . 1.4 Plot with seaborn . fig, axes = plt.subplots(ncols=2,figsize=(8,4)) species_u = penguins[&quot;species&quot;].unique() # plot 0 : matplotlib for i, s in enumerate(species_u): axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C{i}&quot;, label=s, alpha=0.3) axes[0].legend(species_u, title=&quot;species&quot;) axes[0].set_xlabel(&quot;Bill Length (mm)&quot;) axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;) # plot 1 : seaborn sns.scatterplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1]) axes[1].set_xlabel(&quot;Bill Length (mm)&quot;) axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;) fig.tight_layout() . 1.5 matplotlib + seaborn &amp; seaborn + matplotlib . matplotlib과 seaborn이 자유롭게 섞일 수 있습니다. . matplotlib 산점도 위에 seaborn 추세선을 얹을 수 있고, | seaborn 산점도 위에 matplotlib 중심점을 얹을 수 있습니다. | fig, axes = plt.subplots(ncols=2, figsize=(8, 4)) species_u = penguins[&quot;species&quot;].unique() # plot 0 : matplotlib + seaborn for i, s in enumerate(species_u): # matplotlib 산점도 axes[0].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s], penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s], c=f&quot;C{i}&quot;, label=s, alpha=0.3 ) # seaborn 추세선 sns.regplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, data=penguins.loc[penguins[&quot;species&quot;]==s], scatter=False, ax=axes[0]) axes[0].legend(species_u, title=&quot;species&quot;) axes[0].set_xlabel(&quot;Bill Length (mm)&quot;) axes[0].set_ylabel(&quot;Bill Depth (mm)&quot;) # plot 1 : seaborn + matplotlib # seaborn 산점도 sns.scatterplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.3, ax=axes[1]) axes[1].set_xlabel(&quot;Bill Length (mm)&quot;) axes[1].set_ylabel(&quot;Bill Depth (mm)&quot;) for i, s in enumerate(species_u): # matplotlib 중심점 axes[1].scatter(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), c=f&quot;C{i}&quot;, alpha=1, marker=&quot;x&quot;, s=100 ) fig.tight_layout() . 1.6 seaborn + seaborn + matplotlib . fig, ax = plt.subplots(figsize=(6,5)) # plot 0: scatter plot sns.scatterplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, color=&quot;k&quot;, data=penguins, alpha=0.3, ax=ax, legend=False) # plot 1: kde plot sns.kdeplot(x=&quot;bill_length_mm&quot;, y=&quot;bill_depth_mm&quot;, hue=&quot;species&quot;, data=penguins, alpha=0.5, ax=ax, legend=False) # text: species_u = penguins[&quot;species&quot;].unique() for i, s in enumerate(species_u): ax.text(penguins[&quot;bill_length_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), penguins[&quot;bill_depth_mm&quot;].loc[penguins[&quot;species&quot;]==s].mean(), s = s, fontdict={&quot;fontsize&quot;:14, &quot;fontweight&quot;:&quot;bold&quot;,&quot;color&quot;:&quot;k&quot;} ) ax.set_xlabel(&quot;Bill Length (mm)&quot;) ax.set_ylabel(&quot;Bill Depth (mm)&quot;) fig.tight_layout() . Visualization With Seaborn . Seaborn은 matplotlib 기반 파이썬 데이터 시각화 library이다. 그것은 매력적이고 유익한 통계 그래픽을 그리기 위한 높은 수준의 인터페이스를 제공한다. 플롯 스타일 및 색상 기본값에 대한 선택권을 제공하고, 일반적인 통계 플롯 유형에 대한 간단한 고급 함수를 정의하며, Pandas 데이터 프레임에서 제공하는 기능과 통합됩니다. Seaborn의 주요 아이디어는 통계 데이터 탐색 및 일부 통계 모델 적합에 유용한 다양한 플롯 유형을 생성하기 위한 높은 수준의 명령을 제공한다는 것입니다. . import seaborn as sns sns.set() sns.set(style=&quot;darkgrid&quot;) import numpy as np import pandas as pd # importing matplotlib import matplotlib.pyplot as plt %matplotlib inline import warnings warnings.filterwarnings(&quot;ignore&quot;) plt.rcParams[&#39;figure.figsize&#39;]=(10,10) . 빅마트 판매 데이터를 사용할 것이다. 다음에서 데이터를 다운로드할 수 있습니다. https://datahack.analyticsvidhya.com/contest/practice-problem-big-mart-sales-iii/download/train-file . Loading dataset . from google.colab import drive drive.mount(&#39;/content/drive&#39;) . Mounted at /content/drive . data_BM = pd.read_csv(&#39;/content/drive/MyDrive/3-1데이터마이닝/bigmart_data.csv&#39;) # drop the null values data_BM = data_BM.dropna(how=&quot;any&quot;) # multiply Item_Visibility by 100 to increase size data_BM[&quot;Visibility_Scaled&quot;] = data_BM[&quot;Item_Visibility&quot;] * 100 # view the top results data_BM.head() . Item_Identifier Item_Weight Item_Fat_Content Item_Visibility Item_Type Item_MRP Outlet_Identifier Outlet_Establishment_Year Outlet_Size Outlet_Location_Type Outlet_Type Item_Outlet_Sales Visibility_Scaled . 0 FDA15 | 9.300 | Low Fat | 0.016047 | Dairy | 249.8092 | OUT049 | 1999 | Medium | Tier 1 | Supermarket Type1 | 3735.1380 | 1.604730 | . 1 DRC01 | 5.920 | Regular | 0.019278 | Soft Drinks | 48.2692 | OUT018 | 2009 | Medium | Tier 3 | Supermarket Type2 | 443.4228 | 1.927822 | . 2 FDN15 | 17.500 | Low Fat | 0.016760 | Meat | 141.6180 | OUT049 | 1999 | Medium | Tier 1 | Supermarket Type1 | 2097.2700 | 1.676007 | . 4 NCD19 | 8.930 | Low Fat | 0.000000 | Household | 53.8614 | OUT013 | 1987 | High | Tier 3 | Supermarket Type1 | 994.7052 | 0.000000 | . 5 FDP36 | 10.395 | Regular | 0.000000 | Baking Goods | 51.4008 | OUT018 | 2009 | Medium | Tier 3 | Supermarket Type2 | 556.6088 | 0.000000 | . &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;24px&quot;viewBox=&quot;0 0 24 24&quot; width=&quot;24px&quot;&gt; &lt;/svg&gt; 1. &#44592;&#48376; plot &#47564;&#46308;&#44592; . 이제 어떻게 하면 seaborn에 여러 줄이 필요한 기본 plot을 한 줄로 만들 수 있는지 살펴보겠습니다. . &#49440; &#52264;&#53944; . 일부 데이터 집합에서는 한 변수의 변화를 시간 함수로 이해하거나 이와 유사한 연속형 변수를 이해할 수 있습니다. . | seaeborn에서, 이것은 직접 또는 kind=&quot;line&quot;을 설정하여 relplot() 함수로 수행할 수 있습니다 . | . sns.lineplot(x=&quot;Item_Weight&quot;, y=&quot;Item_MRP&quot;,data=data_BM[:50]); . &#47561;&#45824;&#52264;&#53944; . Seaborn에서는 barplot 함수를 사용하여 막대 차트를 생성할 수 있습니다. matplotlib에서 동일한 것을 달성하기 위해 우리는 데이터 범주를 현명하게 그룹화하기 위해 추가 코드를 작성해야 했다. 그리고 나서 우리는 정확하게 나오도록 하기 위해 훨씬 더 많은 코드를 작성해야 했습니다. . sns.barplot(x=&quot;Item_Type&quot;, y=&quot;Item_MRP&quot;, data=data_BM[:5]) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f72b9519590&gt; . Histogram . distplot()을 사용하여 seaborn에 Histogram을 만들 수 있습니다. 사용할 수 있는 옵션이 여러 개 있습니다. | . sns.distplot(data_BM[&#39;Item_MRP&#39;]) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f72b8f94310&gt; . Box plots . boxplot() 을 사용하여 Seaborn에서 상자 그림을 만들 수 있습니다. . | Item_Outlet_Sales(아웃렛_품목 판매)를 시각화해 보겠습니다. . | . sns.boxplot(data_BM[&#39;Item_Outlet_Sales&#39;], orient=&#39;vertical&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f72b8f4fed0&gt; . Violin plot . Violin plot은 box plot와 whisker plot 비슷한 역할을 한다. | 이러한 분포를 비교할 수 있도록 하나 이상의 범주형 변수의 여러 수준에 걸친 정량적 데이터의 분포를 보여 줍니다. | 모든 plot 구성 요소가 실제 데이터 포인트에 해당하는 box plot과 달리, Violin plot은 기본 분포의 커널 밀도 추정을 특징으로 한다. | seaborn의 violinplot()을 사용하여 Violin plot을 만들 수 있습니다. | . sns.violinplot(data_BM[&#39;Item_Outlet_Sales&#39;], orient=&#39;vertical&#39;, color=&#39;magenta&#39;) . &lt;matplotlib.axes._subplots.AxesSubplot at 0x7f72b8ecf550&gt; . Scatter plot . 점 cloud을 사용하여 두 변수의 분포를 나타내며, 각 점은 데이터 집합의 관측치를 나타낸다. | 이 묘사를 통해 그들 사이에 의미 있는 관계가 있는지 여부에 대한 상당한 양의 정보를 추론할 수 있다. | relplotα를 clind=volution 옵션과 함께 사용하여 seaborn에 산점도를 표시할 수 있습니다. 참고: 여기서는 그래프에 데이터의 부분 집합만 사용합니다. | . sns.relplot(x=&quot;Item_MRP&quot;, y=&quot;Item_Outlet_Sales&quot;, data=data_BM[:200], kind=&quot;scatter&quot;); . Hue semantic . 세 번째 변수에 따라 점을 색칠하여 그림에 다른 차원을 추가할 수도 있습니다. seaborn에서는 이를 &quot;Hue semantic&quot;을 사용하는 것으로 지칭한다. . sns.relplot(x=&quot;Item_MRP&quot;, y=&quot;Item_Outlet_Sales&quot;, hue=&quot;Item_Type&quot;,data=data_BM[:200]); . semantic 의미론을 사용할 때, 우리는 seaborn에 더 복잡한 line plot을 만들 수 있다. | 다음 예제에서는 Outlet_Size의 여러 범주에 대해 서로 다른 line plot이 만들어집니다. | . sns.lineplot(x=&quot;Item_Weight&quot;, y=&quot;Item_MRP&quot;,hue=&#39;Outlet_Size&#39;,data=data_BM[:150]); . Bubble plot . 우리는 semantic 의미론을 활용하여 Item_Visibility에 따라 Bubble을 색칠하고 동시에 개별 Bubble의 크기로 사용한다. | . sns.relplot(x=&quot;Item_MRP&quot;, y=&quot;Item_Outlet_Sales&quot;, data=data_BM[:200], kind=&quot;scatter&quot;, size=&quot;Visibility_Scaled&quot;, hue=&quot;Visibility_Scaled&quot;); . Category wise sub plot . SeaBorn의 범주를 기준으로 plot을 생성할 수도 있습니다. | 각 Outlet_Size에 대한 scatter plots를 생성했습니다. | . sns.relplot(x=&quot;Item_Weight&quot;, y=&quot;Item_Visibility&quot;,hue=&#39;Outlet_Size&#39;,style=&#39;Outlet_Size&#39;,col=&#39;Outlet_Size&#39;,data=data_BM[:100]); . 2. Seaborn&#51032; &#49324;&#51204; &#48276;&#51452;&#54805; plots . 범주형 변수의 경우 Seaborn에는 세 개의 서로 다른 과가 있습니다. | . catplot()의 기본 데이터 표현에서는 산점도를 사용합니다. . a. &#48276;&#51452;&#54805; &#49328;&#51216;&#46020; . &#49828;&#53944;&#47549; &#54540;&#47215; . 한 변수가 범주형인 산점도를 그립니다. | catplot()에서 kind=strip을 전달하여 이 값을 생성할 수 있습니다. | . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;, kind=&#39;strip&#39;,data=data_BM[:250]); . Swarm plot . 이 함수는 stripplot()과 유사하지만 점이 겹치지 않도록 범주형 축을 따라 조정됩니다. | 이것은 값의 분포를 더 잘 나타내지만 많은 수의 관측치에 대해서는 잘 확장되지 않습니다.. | 이 값은 catplot()에서 cind=filename을 전달하여 생성할 수 있습니다. | . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;, kind=&#39;swarm&#39;,data=data_BM[:250]); . b. &#48276;&#51452;&#54805; &#48516;&#54252;&#46020; . Box Plots . Box plot에는 분포의 사분위수 값 3개가 극단값과 함께 표시됩니다. -“whiskers”은 하위 사분위수와 상위 사분위수의 1.5 IQR 내에 있는 점까지 확장되며, 이 범위를 벗어난 관측치는 독립적으로 표시됩니다. | 즉, Box plot의 각 값은 데이터의 실제 관측치에 해당합니다. | . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;box&quot;,data=data_BM); . Violin Plots . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;violin&quot;,data=data_BM); . Boxen plots . “letter values”으로 정의된 많은 수의 분위수를 표시하기 때문에 “letter values” plot으로 명명되었다. | 모든 형상이 실제 관측치에 해당하는 분포의 비모수 표현을 표시하는 Box plots와 유사합니다. | 더 많은 분위수를 표시함으로써 분포의 형태, 특히 꼬리에 대한 더 많은 정보를 제공한다. | . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;boxen&quot;,data=data_BM); . Point plot . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;point&quot;,data=data_BM); . Bar plots . sns.catplot(x=&quot;Outlet_Size&quot;, y=&quot;Item_Outlet_Sales&quot;,kind=&quot;bar&quot;,data=data_BM); . 3. Density Plots . histogram 대신, Seborn이 sns.kdeplot에서 수행하는 커널 밀도 추정을 사용하여 분포의 매끄러운 추정치를 얻을 수 있다. . plt.figure(figsize=(10,10)) sns.kdeplot(data_BM[&#39;Item_Visibility&#39;], shade=True); . plt.figure(figsize=(10,10)) sns.kdeplot(data_BM[&#39;Item_MRP&#39;], shade=True); . Histogram과 Density Plot Histograms과 KDE는 distplot를 사용하여 결합할 수 있습니다. . plt.figure(figsize=(10,10)) sns.distplot(data_BM[&#39;Item_Outlet_Sales&#39;]); . 4. Pair plots . joint plots을 더 큰 차원의 데이터 집합으로 일반화하면 pair plots이 완성됩니다. 이는 모든 값의 쌍을 서로 비교하여 표시하려는 경우 다차원 데이터 간의 상관 관계를 탐색하는 데 매우 유용합니다. . | 우리는 세 종류의 홍채 꽃잎과 조각의 측정값을 나열하는 잘 알려진 Iris 데이터 세트를 통해 이를 시연할 것이다. . | . iris = sns.load_dataset(&quot;iris&quot;) iris.head() . sepal_length sepal_width petal_length petal_width species . 0 5.1 | 3.5 | 1.4 | 0.2 | setosa | . 1 4.9 | 3.0 | 1.4 | 0.2 | setosa | . 2 4.7 | 3.2 | 1.3 | 0.2 | setosa | . 3 4.6 | 3.1 | 1.5 | 0.2 | setosa | . 4 5.0 | 3.6 | 1.4 | 0.2 | setosa | . &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; height=&quot;24px&quot;viewBox=&quot;0 0 24 24&quot; width=&quot;24px&quot;&gt; &lt;/svg&gt; 샘플 간의 다차원 관계를 시각화하는 것은 sns.pairplot을 호출하는 것만큼 쉽습니다. . sns.pairplot(iris, hue=&#39;species&#39;, height=2.5); .",
            "url": "https://jh20202792.github.io/JH_20202792/jupyter/python/2022/05/12/_05_13_seaborn_and_matplotlib.html",
            "relUrl": "/jupyter/python/2022/05/12/_05_13_seaborn_and_matplotlib.html",
            "date": " • May 12, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "Numpy 기본",
            "content": "도구 - 넘파이(NumPy) . *넘파이(NumPy)는 파이썬의 과학 컴퓨팅을 위한 기본 라이브러리입니다. 넘파이의 핵심은 강력한 N-차원 배열 객체입니다. 또한 선형 대수, 푸리에(Fourier) 변환, 유사 난수 생성과 같은 유용한 함수들도 제공합니다.&quot; . 구글 코랩에서 실행하기 | &#48176;&#50676; &#49373;&#49457; . numpy를 임포트해 보죠. 대부분의 사람들이 np로 알리아싱하여 임포트합니다: . import numpy as np . np.zeros . zeros 함수는 0으로 채워진 배열을 만듭니다: . np.zeros(5) . array([0., 0., 0., 0., 0.]) . 2D 배열(즉, 행렬)을 만들려면 원하는 행과 열의 크기를 튜플로 전달합니다. 예를 들어 다음은 $3 times 4$ 크기의 행렬입니다: . np.zeros((3,4)) . array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) . &#50857;&#50612; . 넘파이에서 각 차원을 축(axis) 이라고 합니다 | 축의 개수를 랭크(rank) 라고 합니다. 예를 들어, 위의 $3 times 4$ 행렬은 랭크 2인 배열입니다(즉 2차원입니다). | 첫 번째 축의 길이는 3이고 두 번째 축의 길이는 4입니다. | . | 배열의 축 길이를 배열의 크기(shape)라고 합니다. 예를 들어, 위 행렬의 크기는 (3, 4)입니다. | 랭크는 크기의 길이와 같습니다. | . | 배열의 사이즈(size)는 전체 원소의 개수입니다. 축의 길이를 모두 곱해서 구할 수 있습니다(가령, $3 times 4=12$). | . a = np.zeros((3,4)) a . array([[0., 0., 0., 0.], [0., 0., 0., 0.], [0., 0., 0., 0.]]) . a.shape . (3, 4) . a.ndim # len(a.shape)와 같습니다 . 2 . a.size . 12 . N-&#52264;&#50896; &#48176;&#50676; . 임의의 랭크 수를 가진 N-차원 배열을 만들 수 있습니다. 예를 들어, 다음은 크기가 (2,3,4)인 3D 배열(랭크=3)입니다: . np.zeros((2,2,5)) . array([[[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]], [[0., 0., 0., 0., 0.], [0., 0., 0., 0., 0.]]]) . &#48176;&#50676; &#53440;&#51077; . 넘파이 배열의 타입은 ndarray입니다: . type(np.zeros((3,4))) . numpy.ndarray . np.ones . ndarray를 만들 수 있는 넘파이 함수가 많습니다. . 다음은 1로 채워진 $3 times 4$ 크기의 행렬입니다: . np.ones((3,4)) . array([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]) . np.full . 주어진 값으로 지정된 크기의 배열을 초기화합니다. 다음은 π로 채워진 $3 times 4$ 크기의 행렬입니다. . np.full((3,4), np.pi) . array([[3.14159265, 3.14159265, 3.14159265, 3.14159265], [3.14159265, 3.14159265, 3.14159265, 3.14159265], [3.14159265, 3.14159265, 3.14159265, 3.14159265]]) . np.empty . 초기화되지 않은 $2 times 3$ 크기의 배열을 만듭니다(배열의 내용은 예측이 불가능하며 메모리 상황에 따라 달라집니다): . np.empty((2,3)) . array([[9.6677106e-317, 0.0000000e+000, 0.0000000e+000], [0.0000000e+000, 0.0000000e+000, 0.0000000e+000]]) . np.array . array 함수는 파이썬 리스트를 사용하여 ndarray를 초기화합니다: . np.array([[1,2,3,4], [10, 20, 30, 40]]) . array([[ 1, 2, 3, 4], [10, 20, 30, 40]]) . np.arange . 파이썬의 기본 range 함수와 비슷한 넘파이 arange 함수를 사용하여 ndarray를 만들 수 있습니다: . np.arange(1, 5) . array([1, 2, 3, 4]) . 부동 소수도 가능합니다: . np.arange(1.0, 5.0) . array([1., 2., 3., 4.]) . 파이썬의 기본 range 함수처럼 건너 뛰는 정도를 지정할 수 있습니다: . np.arange(1, 5, 0.5) . array([1. , 1.5, 2. , 2.5, 3. , 3.5, 4. , 4.5]) . 부동 소수를 사용하면 원소의 개수가 일정하지 않을 수 있습니다. 예를 들면 다음과 같습니다: . print(np.arange(0, 5/3, 1/3)) # 부동 소수 오차 때문에, 최댓값은 4/3 또는 5/3이 됩니다. print(np.arange(0, 5/3, 0.333333333)) print(np.arange(0, 5/3, 0.333333334)) . [0. 0.33333333 0.66666667 1. 1.33333333 1.66666667] [0. 0.33333333 0.66666667 1. 1.33333333 1.66666667] [0. 0.33333333 0.66666667 1. 1.33333334] . np.linspace . 이런 이유로 부동 소수를 사용할 땐 arange 대신에 linspace 함수를 사용하는 것이 좋습니다. linspace 함수는 지정된 개수만큼 두 값 사이를 나눈 배열을 반환합니다(arange와는 다르게 최댓값이 포함됩니다): . print(np.linspace(0, 5/3, 6)) . [0. 0.33333333 0.66666667 1. 1.33333333 1.66666667] . np.rand&#50752; np.randn . 넘파이의 random 모듈에는 ndarray를 랜덤한 값으로 초기화할 수 있는 함수들이 많이 있습니다. 예를 들어, 다음은 (균등 분포인) 0과 1사이의 랜덤한 부동 소수로 $3 times 4$ 행렬을 초기화합니다: . np.random.rand(3,4) . array([[0.37892456, 0.17966937, 0.38206837, 0.34922123], [0.80462136, 0.9845914 , 0.9416127 , 0.28305275], [0.21201033, 0.54891417, 0.03781613, 0.4369229 ]]) . 다음은 평균이 0이고 분산이 1인 일변량 정규 분포(가우시안 분포)에서 샘플링한 랜덤한 부동 소수를 담은 $3 times 4$ 행렬입니다: . np.random.randn(3,4) . array([[ 0.83811287, -0.57131751, -0.4381827 , 1.1485899 ], [ 1.45316084, -0.47259181, -1.23426057, -0.0669813 ], [ 1.01003549, 1.04381736, -0.93060038, 2.39043293]]) . 이 분포의 모양을 알려면 맷플롯립을 사용해 그려보는 것이 좋습니다(더 자세한 것은 맷플롯립 튜토리얼을 참고하세요): . %matplotlib inline import matplotlib.pyplot as plt . plt.hist(np.random.rand(100000), density=True, bins=100, histtype=&quot;step&quot;, color=&quot;blue&quot;, label=&quot;rand&quot;) plt.hist(np.random.randn(100000), density=True, bins=100, histtype=&quot;step&quot;, color=&quot;red&quot;, label=&quot;randn&quot;) plt.axis([-2.5, 2.5, 0, 1.1]) plt.legend(loc = &quot;upper left&quot;) plt.title(&quot;Random distributions&quot;) plt.xlabel(&quot;Value&quot;) plt.ylabel(&quot;Density&quot;) plt.show() . np.fromfunction . 함수를 사용하여 ndarray를 초기화할 수도 있습니다: . def my_function(z, y, x): return x + 10 * y + 100 * z np.fromfunction(my_function, (3, 2, 10)) . array([[[ 0., 1., 2., 3., 4., 5., 6., 7., 8., 9.], [ 10., 11., 12., 13., 14., 15., 16., 17., 18., 19.]], [[100., 101., 102., 103., 104., 105., 106., 107., 108., 109.], [110., 111., 112., 113., 114., 115., 116., 117., 118., 119.]], [[200., 201., 202., 203., 204., 205., 206., 207., 208., 209.], [210., 211., 212., 213., 214., 215., 216., 217., 218., 219.]]]) . 넘파이는 먼저 크기가 (3, 2, 10)인 세 개의 ndarray(차원마다 하나씩)를 만듭니다. 각 배열은 축을 따라 좌표 값과 같은 값을 가집니다. 예를 들어, z 축에 있는 배열의 모든 원소는 z-축의 값과 같습니다: . [[[ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.] [ 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.]] [[ 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.] [ 1. 1. 1. 1. 1. 1. 1. 1. 1. 1.]] [[ 2. 2. 2. 2. 2. 2. 2. 2. 2. 2.] [ 2. 2. 2. 2. 2. 2. 2. 2. 2. 2.]]] . 위의 식 x + 10 * y + 100 * z에서 x, y, z는 사실 ndarray입니다(배열의 산술 연산에 대해서는 아래에서 설명합니다). 중요한 점은 함수 my_function이 원소마다 호출되는 것이 아니고 딱 한 번 호출된다는 점입니다. 그래서 매우 효율적으로 초기화할 수 있습니다. . &#48176;&#50676; &#45936;&#51060;&#53552; . dtype . 넘파이의 ndarray는 모든 원소가 동일한 타입(보통 숫자)을 가지기 때문에 효율적입니다. dtype 속성으로 쉽게 데이터 타입을 확인할 수 있습니다: . c = np.arange(1, 5) print(c.dtype, c) . int64 [1 2 3 4] . c = np.arange(1.0, 5.0) print(c.dtype, c) . float64 [1. 2. 3. 4.] . 넘파이가 데이터 타입을 결정하도록 내버려 두는 대신 dtype 매개변수를 사용해서 배열을 만들 때 명시적으로 지정할 수 있습니다: . d = np.arange(1, 5, dtype=np.complex64) print(d.dtype, d) . complex64 [1.+0.j 2.+0.j 3.+0.j 4.+0.j] . 가능한 데이터 타입은 int8, int16, int32, int64, uint8|16|32|64, float16|32|64, complex64|128가 있습니다. 전체 리스트는 온라인 문서를 참고하세요. . itemsize . itemsize 속성은 각 아이템의 크기(바이트)를 반환합니다: . e = np.arange(1, 5, dtype=np.complex64) e.itemsize . 8 . data &#48260;&#54140; . 배열의 데이터는 1차원 바이트 버퍼로 메모리에 저장됩니다. data 속성을 사용해 참조할 수 있습니다(사용할 일은 거의 없겠지만요). . f = np.array([[1,2],[1000, 2000]], dtype=np.int32) f.data . &lt;memory at 0x7f97929dd790&gt; . 파이썬 2에서는 f.data가 버퍼이고 파이썬 3에서는 memoryview입니다. . if (hasattr(f.data, &quot;tobytes&quot;)): data_bytes = f.data.tobytes() # python 3 else: data_bytes = memoryview(f.data).tobytes() # python 2 data_bytes . b&#39; x01 x00 x00 x00 x02 x00 x00 x00 xe8 x03 x00 x00 xd0 x07 x00 x00&#39; . 여러 개의 ndarray가 데이터 버퍼를 공유할 수 있습니다. 하나를 수정하면 다른 것도 바뀝니다. 잠시 후에 예를 살펴 보겠습니다. . &#48176;&#50676; &#53356;&#44592; &#48320;&#44221; . &#51088;&#49888;&#51012; &#48320;&#44221; . ndarray의 shape 속성을 지정하면 간단히 크기를 바꿀 수 있습니다. 배열의 원소 개수는 동일하게 유지됩니다. . g = np.arange(24) print(g) print(&quot;랭크:&quot;, g.ndim) . [ 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23] 랭크: 1 . g.shape = (6, 4) print(g) print(&quot;랭크:&quot;, g.ndim) . [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11] [12 13 14 15] [16 17 18 19] [20 21 22 23]] 랭크: 2 . g.shape = (2, 3, 4) print(g) print(&quot;랭크:&quot;, g.ndim) . [[[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] [[12 13 14 15] [16 17 18 19] [20 21 22 23]]] 랭크: 3 . reshape . reshape 함수는 동일한 데이터를 가리키는 새로운 ndarray 객체를 반환합니다. 한 배열을 수정하면 다른 것도 함께 바뀝니다. . g2 = g.reshape(4,6) print(g2) print(&quot;랭크:&quot;, g2.ndim) . [[ 0 1 2 3 4 5] [ 6 7 8 9 10 11] [12 13 14 15 16 17] [18 19 20 21 22 23]] 랭크: 2 . 행 1, 열 2의 원소를 999로 설정합니다(인덱싱 방식은 아래를 참고하세요). . g2[1, 2] = 999 g2 . array([[ 0, 1, 2, 3, 4, 5], [ 6, 7, 999, 9, 10, 11], [ 12, 13, 14, 15, 16, 17], [ 18, 19, 20, 21, 22, 23]]) . 이에 상응하는 g의 원소도 수정됩니다. . g . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [999, 9, 10, 11]], [[ 12, 13, 14, 15], [ 16, 17, 18, 19], [ 20, 21, 22, 23]]]) . ravel . 마지막으로 ravel 함수는 동일한 데이터를 가리키는 새로운 1차원 ndarray를 반환합니다: . g.ravel() . array([ 0, 1, 2, 3, 4, 5, 6, 7, 999, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . &#49328;&#49696; &#50672;&#49328; . 일반적인 산술 연산자(+, -, *, /, //, ** 등)는 모두 ndarray와 사용할 수 있습니다. 이 연산자는 원소별로 적용됩니다: . a = np.array([14, 23, 32, 41]) b = np.array([5, 4, 3, 2]) print(&quot;a + b =&quot;, a + b) print(&quot;a - b =&quot;, a - b) print(&quot;a * b =&quot;, a * b) print(&quot;a / b =&quot;, a / b) print(&quot;a // b =&quot;, a // b) print(&quot;a % b =&quot;, a % b) print(&quot;a ** b =&quot;, a ** b) . a + b = [19 27 35 43] a - b = [ 9 19 29 39] a * b = [70 92 96 82] a / b = [ 2.8 5.75 10.66666667 20.5 ] a // b = [ 2 5 10 20] a % b = [4 3 2 1] a ** b = [537824 279841 32768 1681] . 여기 곱셈은 행렬 곱셈이 아닙니다. 행렬 연산은 아래에서 설명합니다. . 배열의 크기는 같아야 합니다. 그렇지 않으면 넘파이가 브로드캐스팅 규칙을 적용합니다. . &#48652;&#47196;&#46300;&#52880;&#49828;&#54021; . 일반적으로 넘파이는 동일한 크기의 배열을 기대합니다. 그렇지 않은 상황에는 브로드캐시틍 규칙을 적용합니다: . &#44508;&#52825; 1 . 배열의 랭크가 동일하지 않으면 랭크가 맞을 때까지 랭크가 작은 배열 앞에 1을 추가합니다. . h = np.arange(5).reshape(1, 1, 5) h . array([[[0, 1, 2, 3, 4]]]) . 여기에 (1,1,5) 크기의 3D 배열에 (5,) 크기의 1D 배열을 더해 보죠. 브로드캐스팅의 규칙 1이 적용됩니다! . h + [10, 20, 30, 40, 50] # 다음과 동일합니다: h + [[[10, 20, 30, 40, 50]]] . array([[[10, 21, 32, 43, 54]]]) . &#44508;&#52825; 2 . 특정 차원이 1인 배열은 그 차원에서 크기가 가장 큰 배열의 크기에 맞춰 동작합니다. 배열의 원소가 차원을 따라 반복됩니다. . k = np.arange(6).reshape(2, 3) k . array([[0, 1, 2], [3, 4, 5]]) . (2,3) 크기의 2D ndarray에 (2,1) 크기의 2D 배열을 더해 보죠. 넘파이는 브로드캐스팅 규칙 2를 적용합니다: . k + [[100], [200]] # 다음과 같습니다: k + [[100, 100, 100], [200, 200, 200]] . array([[100, 101, 102], [203, 204, 205]]) . 규칙 1과 2를 합치면 다음과 같이 동작합니다: . k + [100, 200, 300] # 규칙 1 적용: [[100, 200, 300]], 규칙 2 적용: [[100, 200, 300], [100, 200, 300]] . array([[100, 201, 302], [103, 204, 305]]) . 또 매우 간단히 다음 처럼 해도 됩니다: . k + 1000 # 다음과 같습니다: k + [[1000, 1000, 1000], [1000, 1000, 1000]] . array([[1000, 1001, 1002], [1003, 1004, 1005]]) . &#44508;&#52825; 3 . 규칙 1 &amp; 2을 적용했을 때 모든 배열의 크기가 맞아야 합니다. . try: k + [33, 44] except ValueError as e: print(e) . operands could not be broadcast together with shapes (2,3) (2,) . 브로드캐스팅 규칙은 산술 연산 뿐만 아니라 넘파이 연산에서 많이 사용됩니다. 아래에서 더 보도록 하죠. 브로드캐스팅에 관한 더 자세한 정보는 온라인 문서를 참고하세요. . &#50629;&#52880;&#49828;&#54021; . dtype이 다른 배열을 합칠 때 넘파이는 (실제 값에 상관없이) 모든 값을 다룰 수 있는 타입으로 업캐스팅합니다. . k1 = np.arange(0, 5, dtype=np.uint8) print(k1.dtype, k1) . uint8 [0 1 2 3 4] . k2 = k1 + np.array([5, 6, 7, 8, 9], dtype=np.int8) print(k2.dtype, k2) . int16 [ 5 7 9 11 13] . 모든 int8과 uint8 값(-128에서 255까지)을 표현하기 위해 int16이 필요합니다. 이 코드에서는 uint8이면 충분하지만 업캐스팅되었습니다. . k3 = k1 + 1.5 print(k3.dtype, k3) . float64 [1.5 2.5 3.5 4.5 5.5] . &#51312;&#44148; &#50672;&#49328;&#51088; . 조건 연산자도 원소별로 적용됩니다: . m = np.array([20, -5, 30, 40]) m &lt; [15, 16, 35, 36] . array([False, True, True, False]) . 브로드캐스팅을 사용합니다: . m &lt; 25 # m &lt; [25, 25, 25, 25] 와 동일 . array([ True, True, False, False]) . 불리언 인덱싱과 함께 사용하면 아주 유용합니다(아래에서 설명하겠습니다). . m[m &lt; 25] . array([20, -5]) . &#49688;&#54617; &#54632;&#49688;&#50752; &#53685;&#44228; &#54632;&#49688; . ndarray에서 사용할 수 있는 수학 함수와 통계 함수가 많습니다. . ndarray &#47700;&#49436;&#46300; . 일부 함수는 ndarray 메서드로 제공됩니다. 예를 들면: . a = np.array([[-2.5, 3.1, 7], [10, 11, 12]]) print(a) print(&quot;평균 =&quot;, a.mean()) . [[-2.5 3.1 7. ] [10. 11. 12. ]] 평균 = 6.766666666666667 . 이 명령은 크기에 상관없이 ndarray에 있는 모든 원소의 평균을 계산합니다. . 다음은 유용한 ndarray 메서드입니다: . for func in (a.min, a.max, a.sum, a.prod, a.std, a.var): print(func.__name__, &quot;=&quot;, func()) . min = -2.5 max = 12.0 sum = 40.6 prod = -71610.0 std = 5.084835843520964 var = 25.855555555555554 . 이 함수들은 선택적으로 매개변수 axis를 사용합니다. 지정된 축을 따라 원소에 연산을 적용하는데 사용합니다. 예를 들면: . c=np.arange(24).reshape(2,3,4) c . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) . c.sum(axis=0) # 첫 번째 축을 따라 더함, 결과는 3x4 배열 . array([[12, 14, 16, 18], [20, 22, 24, 26], [28, 30, 32, 34]]) . c.sum(axis=1) # 두 번째 축을 따라 더함, 결과는 2x4 배열 . array([[12, 15, 18, 21], [48, 51, 54, 57]]) . 여러 축에 대해서 더할 수도 있습니다: . c.sum(axis=(0,2)) # 첫 번째 축과 세 번째 축을 따라 더함, 결과는 (3,) 배열 . array([ 60, 92, 124]) . 0+1+2+3 + 12+13+14+15, 4+5+6+7 + 16+17+18+19, 8+9+10+11 + 20+21+22+23 . (60, 92, 124) . &#51068;&#48152; &#54632;&#49688; . 넘파이는 일반 함수(universal function) 또는 ufunc라고 부르는 원소별 함수를 제공합니다. 예를 들면 square 함수는 원본 ndarray를 복사하여 각 원소를 제곱한 새로운 ndarray 객체를 반환합니다: . a = np.array([[-2.5, 3.1, 7], [10, 11, 12]]) np.square(a) . array([[ 6.25, 9.61, 49. ], [100. , 121. , 144. ]]) . 다음은 유용한 단항 일반 함수들입니다: . print(&quot;원본 ndarray&quot;) print(a) for func in (np.abs, np.sqrt, np.exp, np.log, np.sign, np.ceil, np.modf, np.isnan, np.cos): print(&quot; n&quot;, func.__name__) print(func(a)) . 원본 ndarray [[-2.5 3.1 7. ] [10. 11. 12. ]] absolute [[ 2.5 3.1 7. ] [10. 11. 12. ]] sqrt [[ nan 1.76068169 2.64575131] [3.16227766 3.31662479 3.46410162]] exp [[8.20849986e-02 2.21979513e+01 1.09663316e+03] [2.20264658e+04 5.98741417e+04 1.62754791e+05]] log [[ nan 1.13140211 1.94591015] [2.30258509 2.39789527 2.48490665]] sign [[-1. 1. 1.] [ 1. 1. 1.]] ceil [[-2. 4. 7.] [10. 11. 12.]] modf (array([[-0.5, 0.1, 0. ], [ 0. , 0. , 0. ]]), array([[-2., 3., 7.], [10., 11., 12.]])) isnan [[False False False] [False False False]] cos [[-0.80114362 -0.99913515 0.75390225] [-0.83907153 0.0044257 0.84385396]] . &lt;ipython-input-59-d791c8e37e6f&gt;:5: RuntimeWarning: invalid value encountered in sqrt print(func(a)) &lt;ipython-input-59-d791c8e37e6f&gt;:5: RuntimeWarning: invalid value encountered in log print(func(a)) . &#51060;&#54637; &#51068;&#48152; &#54632;&#49688; . 두 개의 ndarray에 원소별로 적용되는 이항 함수도 많습니다. 두 배열이 동일한 크기가 아니면 브로드캐스팅 규칙이 적용됩니다: . a = np.array([1, -2, 3, 4]) b = np.array([2, 8, -1, 7]) np.add(a, b) # a + b 와 동일 . array([ 3, 6, 2, 11]) . np.greater(a, b) # a &gt; b 와 동일 . array([False, False, True, False]) . np.maximum(a, b) . array([2, 8, 3, 7]) . np.copysign(a, b) . array([ 1., 2., -3., 4.]) . &#48176;&#50676; &#51064;&#45937;&#49905; . 1&#52264;&#50896; &#48176;&#50676; . 1차원 넘파이 배열은 보통의 파이썬 배열과 비슷하게 사용할 수 있습니다: . a = np.array([1, 5, 3, 19, 13, 7, 3]) a[3] . 19 . a[2:5] . array([ 3, 19, 13]) . a[2:-1] . array([ 3, 19, 13, 7]) . a[:2] . array([1, 5]) . a[2::2] . array([ 3, 13, 3]) . a[::-1] . array([ 3, 7, 13, 19, 3, 5, 1]) . 물론 원소를 수정할 수 있죠: . a[3]=999 a . array([ 1, 5, 3, 999, 13, 7, 3]) . 슬라이싱을 사용해 ndarray를 수정할 수 있습니다: . a[2:5] = [997, 998, 999] a . array([ 1, 5, 997, 998, 999, 7, 3]) . &#48372;&#53685;&#51032; &#54028;&#51060;&#50028; &#48176;&#50676;&#44284; &#52264;&#51060;&#51216; . 보통의 파이썬 배열과 대조적으로 ndarray 슬라이싱에 하나의 값을 할당하면 슬라이싱 전체에 복사됩니다. 위에서 언급한 브로드캐스팅 덕택입니다. . a[2:5] = -1 a . array([ 1, 5, -1, -1, -1, 7, 3]) . 또한 이런 식으로 ndarray 크기를 늘리거나 줄일 수 없습니다: . try: a[2:5] = [1,2,3,4,5,6] # 너무 길어요 except ValueError as e: print(e) . cannot copy sequence with size 6 to array axis with dimension 3 . 원소를 삭제할 수도 없습니다: . try: del a[2:5] except ValueError as e: print(e) . cannot delete array elements . 중요한 점은 ndarray의 슬라이싱은 같은 데이터 버퍼를 바라보는 뷰(view)입니다. 슬라이싱된 객체를 수정하면 실제 원본 ndarray가 수정됩니다! . a_slice = a[2:6] a_slice[1] = 1000 a # 원본 배열이 수정됩니다! . array([ 1, 5, -1, 1000, -1, 7, 3]) . a[3] = 2000 a_slice # 비슷하게 원본 배열을 수정하면 슬라이싱 객체에도 반영됩니다! . array([ -1, 2000, -1, 7]) . 데이터를 복사하려면 copy 메서드를 사용해야 합니다: . another_slice = a[2:6].copy() another_slice[1] = 3000 a # 원본 배열이 수정되지 않습니다 . array([ 1, 5, -1, 2000, -1, 7, 3]) . a[3] = 4000 another_slice # 마찬가지로 원본 배열을 수정해도 복사된 배열은 바뀌지 않습니다 . array([ -1, 3000, -1, 7]) . &#45796;&#52264;&#50896; &#48176;&#50676; . 다차원 배열은 비슷한 방식으로 각 축을 따라 인덱싱 또는 슬라이싱해서 사용합니다. 콤마로 구분합니다: . b = np.arange(48).reshape(4, 12) b . array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]]) . b[1, 2] # 행 1, 열 2 . 14 . b[1, :] # 행 1, 모든 열 . array([12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . b[:, 1] # 모든 행, 열 1 . array([ 1, 13, 25, 37]) . 주의: 다음 두 표현에는 미묘한 차이가 있습니다: . b[1, :] . array([12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]) . b[1:2, :] . array([[12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23]]) . 첫 번째 표현식은 (12,) 크기인 1D 배열로 행이 하나입니다. 두 번째는 (1, 12) 크기인 2D 배열로 같은 행을 반환합니다. . &#54060;&#49884; &#51064;&#45937;&#49905;(Fancy indexing) . 관심 대상의 인덱스 리스트를 지정할 수도 있습니다. 이를 팬시 인덱싱이라고 부릅니다. . b[(0,2), 2:5] # 행 0과 2, 열 2에서 4(5-1)까지 . array([[ 2, 3, 4], [26, 27, 28]]) . b[:, (-1, 2, -1)] # 모든 행, 열 -1 (마지막), 2와 -1 (다시 반대 방향으로) . array([[11, 2, 11], [23, 14, 23], [35, 26, 35], [47, 38, 47]]) . 여러 개의 인덱스 리스트를 지정하면 인덱스에 맞는 값이 포함된 1D ndarray를 반환됩니다. . b[(-1, 2, -1, 2), (5, 9, 1, 9)] # returns a 1D array with b[-1, 5], b[2, 9], b[-1, 1] and b[2, 9] (again) . array([41, 33, 37, 33]) . &#44256;&#52264;&#50896; . 고차원에서도 동일한 방식이 적용됩니다. 몇 가지 예를 살펴 보겠습니다: . c = b.reshape(4,2,6) c . array([[[ 0, 1, 2, 3, 4, 5], [ 6, 7, 8, 9, 10, 11]], [[12, 13, 14, 15, 16, 17], [18, 19, 20, 21, 22, 23]], [[24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35]], [[36, 37, 38, 39, 40, 41], [42, 43, 44, 45, 46, 47]]]) . c[2, 1, 4] # 행렬 2, 행 1, 열 4 . 34 . c[2, :, 3] # 행렬 2, 모든 행, 열 3 . array([27, 33]) . 어떤 축에 대한 인덱스를 지정하지 않으면 이 축의 모든 원소가 반환됩니다: . c[2, 1] # 행렬 2, 행 1, 모든 열이 반환됩니다. c[2, 1, :]와 동일합니다. . array([30, 31, 32, 33, 34, 35]) . &#49373;&#47029; &#48512;&#54840; (...) . 생략 부호(...)를 쓰면 모든 지정하지 않은 축의 원소를 포함합니다. . c[2, ...] # 행렬 2, 모든 행, 모든 열. c[2, :, :]와 동일 . array([[24, 25, 26, 27, 28, 29], [30, 31, 32, 33, 34, 35]]) . c[2, 1, ...] # 행렬 2, 행 1, 모든 열. c[2, 1, :]와 동일 . array([30, 31, 32, 33, 34, 35]) . c[2, ..., 3] # 행렬 2, 모든 행, 열 3. c[2, :, 3]와 동일 . array([27, 33]) . c[..., 3] # 모든 행렬, 모든 행, 열 3. c[:, :, 3]와 동일 . array([[ 3, 9], [15, 21], [27, 33], [39, 45]]) . &#48520;&#47532;&#50616; &#51064;&#45937;&#49905; . 불리언 값을 가진 ndarray를 사용해 축의 인덱스를 지정할 수 있습니다. . b = np.arange(48).reshape(4, 12) b . array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23], [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35], [36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47]]) . rows_on = np.array([True, False, True, False]) b[rows_on, :] # 행 0과 2, 모든 열. b[(0, 2), :]와 동일 . array([[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11], [24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35]]) . cols_on = np.array([False, True, False] * 4) b[:, cols_on] # 모든 행, 열 1, 4, 7, 10 . array([[ 1, 4, 7, 10], [13, 16, 19, 22], [25, 28, 31, 34], [37, 40, 43, 46]]) . np.ix_ . 여러 축에 걸쳐서는 불리언 인덱싱을 사용할 수 없고 ix_ 함수를 사용합니다: . b[np.ix_(rows_on, cols_on)] . array([[ 1, 4, 7, 10], [25, 28, 31, 34]]) . np.ix_(rows_on, cols_on) . (array([[0], [2]]), array([[ 1, 4, 7, 10]])) . ndarray와 같은 크기의 불리언 배열을 사용하면 해당 위치가 True인 모든 원소를 담은 1D 배열이 반환됩니다. 일반적으로 조건 연산자와 함께 사용합니다: . b[b % 3 == 1] . array([ 1, 4, 7, 10, 13, 16, 19, 22, 25, 28, 31, 34, 37, 40, 43, 46]) . &#48152;&#48373; . ndarray를 반복하는 것은 일반적인 파이썬 배열을 반복한는 것과 매우 유사합니다. 다차원 배열을 반복하면 첫 번째 축에 대해서 수행됩니다. . c = np.arange(24).reshape(2, 3, 4) # 3D 배열 (두 개의 3x4 행렬로 구성됨) c . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]) . for m in c: print(&quot;아이템:&quot;) print(m) . 아이템: [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] 아이템: [[12 13 14 15] [16 17 18 19] [20 21 22 23]] . for i in range(len(c)): # len(c) == c.shape[0] print(&quot;아이템:&quot;) print(c[i]) . 아이템: [[ 0 1 2 3] [ 4 5 6 7] [ 8 9 10 11]] 아이템: [[12 13 14 15] [16 17 18 19] [20 21 22 23]] . ndarray에 있는 모든 원소를 반복하려면 flat 속성을 사용합니다: . for i in c.flat: print(&quot;아이템:&quot;, i) . 아이템: 0 아이템: 1 아이템: 2 아이템: 3 아이템: 4 아이템: 5 아이템: 6 아이템: 7 아이템: 8 아이템: 9 아이템: 10 아이템: 11 아이템: 12 아이템: 13 아이템: 14 아이템: 15 아이템: 16 아이템: 17 아이템: 18 아이템: 19 아이템: 20 아이템: 21 아이템: 22 아이템: 23 . &#48176;&#50676; &#49939;&#44592; . 종종 다른 배열을 쌓아야 할 때가 있습니다. 넘파이는 이를 위해 몇 개의 함수를 제공합니다. 먼저 배열 몇 개를 만들어 보죠. . q1 = np.full((3,4), 1.0) q1 . array([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]]) . q2 = np.full((4,4), 2.0) q2 . array([[2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.]]) . q3 = np.full((3,4), 3.0) q3 . array([[3., 3., 3., 3.], [3., 3., 3., 3.], [3., 3., 3., 3.]]) . vstack . vstack 함수를 사용하여 수직으로 쌓아보죠: . q4 = np.vstack((q1, q2, q3)) q4 . array([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [3., 3., 3., 3.], [3., 3., 3., 3.], [3., 3., 3., 3.]]) . q4.shape . (10, 4) . q1, q2, q3가 모두 같은 크기이므로 가능합니다(수직으로 쌓기 때문에 수직 축은 크기가 달라도 됩니다). . hstack . hstack을 사용해 수평으로도 쌓을 수 있습니다: . q5 = np.hstack((q1, q3)) q5 . array([[1., 1., 1., 1., 3., 3., 3., 3.], [1., 1., 1., 1., 3., 3., 3., 3.], [1., 1., 1., 1., 3., 3., 3., 3.]]) . q5.shape . (3, 8) . q1과 q3가 모두 3개의 행을 가지고 있기 때문에 가능합니다. q2는 4개의 행을 가지고 있기 때문에 q1, q3와 수평으로 쌓을 수 없습니다: . try: q5 = np.hstack((q1, q2, q3)) except ValueError as e: print(e) . all the input array dimensions for the concatenation axis must match exactly, but along dimension 0, the array at index 0 has size 3 and the array at index 1 has size 4 . concatenate . concatenate 함수는 지정한 축으로도 배열을 쌓습니다. . q7 = np.concatenate((q1, q2, q3), axis=0) # vstack과 동일 q7 . array([[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [2., 2., 2., 2.], [3., 3., 3., 3.], [3., 3., 3., 3.], [3., 3., 3., 3.]]) . q7.shape . (10, 4) . 예상했겠지만 hstack은 axis=1으로 concatenate를 호출하는 것과 같습니다. . stack . stack 함수는 새로운 축을 따라 배열을 쌓습니다. 모든 배열은 같은 크기를 가져야 합니다. . q8 = np.stack((q1, q3)) q8 . array([[[1., 1., 1., 1.], [1., 1., 1., 1.], [1., 1., 1., 1.]], [[3., 3., 3., 3.], [3., 3., 3., 3.], [3., 3., 3., 3.]]]) . q8.shape . (2, 3, 4) . &#48176;&#50676; &#48516;&#54624; . 분할은 쌓기의 반대입니다. 예를 들어 vsplit 함수는 행렬을 수직으로 분할합니다. . 먼저 6x4 행렬을 만들어 보죠: . r = np.arange(24).reshape(6,4) r . array([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]) . 수직으로 동일한 크기로 나누어 보겠습니다: . r1, r2, r3 = np.vsplit(r, 3) r1 . array([[0, 1, 2, 3], [4, 5, 6, 7]]) . r2 . array([[ 8, 9, 10, 11], [12, 13, 14, 15]]) . r3 . array([[16, 17, 18, 19], [20, 21, 22, 23]]) . split 함수는 주어진 축을 따라 배열을 분할합니다. vsplit는 axis=0으로 split를 호출하는 것과 같습니다. hsplit 함수는 axis=1로 split를 호출하는 것과 같습니다: . r4, r5 = np.hsplit(r, 2) r4 . array([[ 0, 1], [ 4, 5], [ 8, 9], [12, 13], [16, 17], [20, 21]]) . r5 . array([[ 2, 3], [ 6, 7], [10, 11], [14, 15], [18, 19], [22, 23]]) . &#48176;&#50676; &#51204;&#52824; . transpose 메서드는 주어진 순서대로 축을 뒤바꾸어 ndarray 데이터에 대한 새로운 뷰를 만듭니다. . 예를 위해 3D 배열을 만들어 보죠: . t = np.arange(24).reshape(4,2,3) t . array([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]], [[12, 13, 14], [15, 16, 17]], [[18, 19, 20], [21, 22, 23]]]) . 0, 1, 2(깊이, 높이, 너비) 축을 1, 2, 0 (깊이→너비, 높이→깊이, 너비→높이) 순서로 바꾼 ndarray를 만들어 보겠습니다: . t1 = t.transpose((1,2,0)) t1 . array([[[ 0, 6, 12, 18], [ 1, 7, 13, 19], [ 2, 8, 14, 20]], [[ 3, 9, 15, 21], [ 4, 10, 16, 22], [ 5, 11, 17, 23]]]) . t1.shape . (2, 3, 4) . transpose 기본값은 차원의 순서를 역전시킵니다: . t2 = t.transpose() # t.transpose((2, 1, 0))와 동일 t2 . array([[[ 0, 6, 12, 18], [ 3, 9, 15, 21]], [[ 1, 7, 13, 19], [ 4, 10, 16, 22]], [[ 2, 8, 14, 20], [ 5, 11, 17, 23]]]) . t2.shape . (3, 2, 4) . 넘파이는 두 축을 바꾸는 swapaxes 함수를 제공합니다. 예를 들어 깊이와 높이를 뒤바꾸어 t의 새로운 뷰를 만들어 보죠: . t3 = t.swapaxes(0,1) # t.transpose((1, 0, 2))와 동일 t3 . array([[[ 0, 1, 2], [ 6, 7, 8], [12, 13, 14], [18, 19, 20]], [[ 3, 4, 5], [ 9, 10, 11], [15, 16, 17], [21, 22, 23]]]) . t3.shape . (2, 4, 3) . &#49440;&#54805; &#45824;&#49688;&#54617; . 넘파이 2D 배열을 사용하면 파이썬에서 행렬을 효율적으로 표현할 수 있습니다. 주요 행렬 연산을 간단히 둘러 보겠습니다. 선형 대수학, 벡터와 행렬에 관한 자세한 내용은 Linear Algebra tutorial를 참고하세요. . &#54665;&#47148; &#51204;&#52824; . T 속성은 랭크가 2보다 크거나 같을 때 transpose()를 호출하는 것과 같습니다: . m1 = np.arange(10).reshape(2,5) m1 . array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) . m1.T . array([[0, 5], [1, 6], [2, 7], [3, 8], [4, 9]]) . T 속성은 랭크가 0이거나 1인 배열에는 아무런 영향을 미치지 않습니다: . m2 = np.arange(5) m2 . array([0, 1, 2, 3, 4]) . m2.T . array([0, 1, 2, 3, 4]) . 먼저 1D 배열을 하나의 행이 있는 행렬(2D)로 바꾼다음 전치를 수행할 수 있습니다: . m2r = m2.reshape(1,5) m2r . array([[0, 1, 2, 3, 4]]) . m2r.T . array([[0], [1], [2], [3], [4]]) . &#54665;&#47148; &#44273;&#49480; . 두 개의 행렬을 만들어 dot 메서드로 행렬 곱셈을 실행해 보죠. . n1 = np.arange(10).reshape(2, 5) n1 . array([[0, 1, 2, 3, 4], [5, 6, 7, 8, 9]]) . n2 = np.arange(15).reshape(5,3) n2 . array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11], [12, 13, 14]]) . n1.dot(n2) . array([[ 90, 100, 110], [240, 275, 310]]) . 주의: 앞서 언급한 것처럼 n1*n2는 행렬 곱셈이 아니라 원소별 곱셈(또는 아다마르 곱이라 부릅니다)입니다. . &#50669;&#54665;&#47148;&#44284; &#50976;&#49324; &#50669;&#54665;&#47148; . numpy.linalg 모듈 안에 많은 선형 대수 함수들이 있습니다. 특히 inv 함수는 정방 행렬의 역행렬을 계산합니다: . import numpy.linalg as linalg m3 = np.array([[1,2,3],[5,7,11],[21,29,31]]) m3 . array([[ 1, 2, 3], [ 5, 7, 11], [21, 29, 31]]) . linalg.inv(m3) . array([[-2.31818182, 0.56818182, 0.02272727], [ 1.72727273, -0.72727273, 0.09090909], [-0.04545455, 0.29545455, -0.06818182]]) . pinv 함수를 사용하여 유사 역행렬을 계산할 수도 있습니다: . linalg.pinv(m3) . array([[-2.31818182, 0.56818182, 0.02272727], [ 1.72727273, -0.72727273, 0.09090909], [-0.04545455, 0.29545455, -0.06818182]]) . &#45800;&#50948; &#54665;&#47148; . 행렬과 그 행렬의 역행렬을 곱하면 단위 행렬이 됩니다(작은 소숫점 오차가 있습니다): . m3.dot(linalg.inv(m3)) . array([[ 1.00000000e+00, -1.66533454e-16, 0.00000000e+00], [ 6.31439345e-16, 1.00000000e+00, -1.38777878e-16], [ 5.21110932e-15, -2.38697950e-15, 1.00000000e+00]]) . eye 함수는 NxN 크기의 단위 행렬을 만듭니다: . np.eye(3) . array([[1., 0., 0.], [0., 1., 0.], [0., 0., 1.]]) . QR &#48516;&#54644; . qr 함수는 행렬을 QR 분해합니다: . q, r = linalg.qr(m3) q . array([[-0.04627448, 0.98786672, 0.14824986], [-0.23137241, 0.13377362, -0.96362411], [-0.97176411, -0.07889213, 0.22237479]]) . r . array([[-21.61018278, -29.89331494, -32.80860727], [ 0. , 0.62427688, 1.9894538 ], [ 0. , 0. , -3.26149699]]) . q.dot(r) # q.r는 m3와 같습니다 . array([[ 1., 2., 3.], [ 5., 7., 11.], [21., 29., 31.]]) . &#54665;&#47148;&#49885; . det 함수는 행렬식을 계산합니다: . linalg.det(m3) # 행렬식 계산 . 43.99999999999997 . &#44256;&#50995;&#44050;&#44284; &#44256;&#50976;&#48289;&#53552; . eig 함수는 정방 행렬의 고윳값과 고유벡터를 계산합니다: . eigenvalues, eigenvectors = linalg.eig(m3) eigenvalues # λ . array([42.26600592, -0.35798416, -2.90802176]) . eigenvectors # v . array([[-0.08381182, -0.76283526, -0.18913107], [-0.3075286 , 0.64133975, -0.6853186 ], [-0.94784057, -0.08225377, 0.70325518]]) . m3.dot(eigenvectors) - eigenvalues * eigenvectors # m3.v - λ*v = 0 . array([[ 8.88178420e-15, 2.22044605e-16, -3.10862447e-15], [ 3.55271368e-15, 2.02615702e-15, -1.11022302e-15], [ 3.55271368e-14, 3.33413852e-15, -8.43769499e-15]]) . &#53945;&#51079;&#44050; &#48516;&#54644; . svd 함수는 행렬을 입력으로 받아 그 행렬의 특잇값 분해를 반환합니다: . m4 = np.array([[1,0,0,0,2], [0,0,3,0,0], [0,0,0,0,0], [0,2,0,0,0]]) m4 . array([[1, 0, 0, 0, 2], [0, 0, 3, 0, 0], [0, 0, 0, 0, 0], [0, 2, 0, 0, 0]]) . U, S_diag, V = linalg.svd(m4) U . array([[ 0., 1., 0., 0.], [ 1., 0., 0., 0.], [ 0., 0., 0., -1.], [ 0., 0., 1., 0.]]) . S_diag . array([3. , 2.23606798, 2. , 0. ]) . svd 함수는 Σ의 대각 원소 값만 반환합니다. 전체 Σ 행렬은 다음과 같이 만듭니다: . S = np.zeros((4, 5)) S[np.diag_indices(4)] = S_diag S # Σ . array([[3. , 0. , 0. , 0. , 0. ], [0. , 2.23606798, 0. , 0. , 0. ], [0. , 0. , 2. , 0. , 0. ], [0. , 0. , 0. , 0. , 0. ]]) . V . array([[-0. , 0. , 1. , -0. , 0. ], [ 0.4472136 , 0. , 0. , 0. , 0.89442719], [-0. , 1. , 0. , -0. , 0. ], [ 0. , 0. , 0. , 1. , 0. ], [-0.89442719, 0. , 0. , 0. , 0.4472136 ]]) . U.dot(S).dot(V) # U.Σ.V == m4 . array([[1., 0., 0., 0., 2.], [0., 0., 3., 0., 0.], [0., 0., 0., 0., 0.], [0., 2., 0., 0., 0.]]) . &#45824;&#44033;&#50896;&#49548;&#50752; &#45824;&#44033;&#54633; . np.diag(m3) # m3의 대각 원소입니다(왼쪽 위에서 오른쪽 아래) . array([ 1, 7, 31]) . np.trace(m3) # np.diag(m3).sum()와 같습니다 . 39 . &#49440;&#54805; &#48169;&#51221;&#49885; &#54400;&#44592; . solve 함수는 다음과 같은 선형 방정식을 풉니다: . $2x + 6y = 6$ | $5x + 3y = -9$ | . coeffs = np.array([[2, 6], [5, 3]]) depvars = np.array([6, -9]) solution = linalg.solve(coeffs, depvars) solution . array([-3., 2.]) . solution을 확인해 보죠: . coeffs.dot(solution), depvars # 네 같네요 . (array([ 6., -9.]), array([ 6, -9])) . 좋습니다! 다른 방식으로도 solution을 확인해 보죠: . np.allclose(coeffs.dot(solution), depvars) . True . &#48289;&#53552;&#54868; . 한 번에 하나씩 개별 배열 원소에 대해 연산을 실행하는 대신 배열 연산을 사용하면 훨씬 효율적인 코드를 만들 수 있습니다. 이를 벡터화라고 합니다. 이를 사용하여 넘파이의 최적화된 성능을 활용할 수 있습니다. . 예를 들어, $sin(xy/40.5)$ 식을 기반으로 768x1024 크기 배열을 생성하려고 합니다. 중첩 반복문 안에 파이썬의 math 함수를 사용하는 것은 나쁜 방법입니다: . import math data = np.empty((768, 1024)) for y in range(768): for x in range(1024): data[y, x] = math.sin(x*y/40.5) # 매우 비효율적입니다! . 작동은 하지만 순수한 파이썬 코드로 반복문이 진행되기 때문에 아주 비효율적입니다. 이 알고리즘을 벡터화해 보죠. 먼저 넘파이 meshgrid 함수로 좌표 벡터를 사용해 행렬을 만듭니다. . x_coords = np.arange(0, 1024) # [0, 1, 2, ..., 1023] y_coords = np.arange(0, 768) # [0, 1, 2, ..., 767] X, Y = np.meshgrid(x_coords, y_coords) X . array([[ 0, 1, 2, ..., 1021, 1022, 1023], [ 0, 1, 2, ..., 1021, 1022, 1023], [ 0, 1, 2, ..., 1021, 1022, 1023], ..., [ 0, 1, 2, ..., 1021, 1022, 1023], [ 0, 1, 2, ..., 1021, 1022, 1023], [ 0, 1, 2, ..., 1021, 1022, 1023]]) . Y . array([[ 0, 0, 0, ..., 0, 0, 0], [ 1, 1, 1, ..., 1, 1, 1], [ 2, 2, 2, ..., 2, 2, 2], ..., [765, 765, 765, ..., 765, 765, 765], [766, 766, 766, ..., 766, 766, 766], [767, 767, 767, ..., 767, 767, 767]]) . 여기서 볼 수 있듯이 X와 Y 모두 768x1024 배열입니다. X에 있는 모든 값은 수평 좌표에 해당합니다. Y에 있는 모든 값은 수직 좌표에 해당합니다. . 이제 간단히 배열 연산을 사용해 계산할 수 있습니다: . data = np.sin(X*Y/40.5) . 맷플롯립의 imshow 함수를 사용해 이 데이터를 그려보죠(matplotlib tutorial을 참조하세요). . import matplotlib.pyplot as plt import matplotlib.cm as cm fig = plt.figure(1, figsize=(7, 6)) plt.imshow(data, cmap=cm.hot) plt.show() . &#51200;&#51109;&#44284; &#47196;&#46377; . 넘파이는 ndarray를 바이너리 또는 텍스트 포맷으로 손쉽게 저장하고 로드할 수 있습니다. . &#48148;&#51060;&#45320;&#47532; .npy &#54252;&#47607; . 랜덤 배열을 만들고 저장해 보죠. . a = np.random.rand(2,3) a . array([[0.5435938 , 0.92886307, 0.01535158], [0.4157283 , 0.9102127 , 0.55129708]]) . np.save(&quot;my_array&quot;, a) . 끝입니다! 파일 이름의 확장자를 지정하지 않았기 때문에 넘파이는 자동으로 .npy를 붙입니다. 파일 내용을 확인해 보겠습니다: . with open(&quot;my_array.npy&quot;, &quot;rb&quot;) as f: content = f.read() content . b&#34; x93NUMPY x01 x00v x00{&#39;descr&#39;: &#39;&lt;f8&#39;, &#39;fortran_order&#39;: False, &#39;shape&#39;: (2, 3), } nY xc1 xfc xd0 x1ee xe1? xde{3 t? xb9 xed? x80V x08 xef xa5p x8f? x96I} xe0J x9b xda? xe0U xfaav xed? xd8 xe50 xc59 xa4 xe1?&#34; . 이 파일을 넘파이 배열로 로드하려면 load 함수를 사용합니다: . a_loaded = np.load(&quot;my_array.npy&quot;) a_loaded . array([[0.5435938 , 0.92886307, 0.01535158], [0.4157283 , 0.9102127 , 0.55129708]]) . &#53581;&#49828;&#53944; &#54252;&#47607; . 배열을 텍스트 포맷으로 저장해 보죠: . np.savetxt(&quot;my_array.csv&quot;, a) . 파일 내용을 확인해 보겠습니다: . with open(&quot;my_array.csv&quot;, &quot;rt&quot;) as f: print(f.read()) . 5.435937959464737235e-01 9.288630656918674955e-01 1.535157809943688001e-02 4.157283012656532994e-01 9.102126992826775620e-01 5.512970782648904944e-01 . 이 파일은 탭으로 구분된 CSV 파일입니다. 다른 구분자를 지정할 수도 있습니다: . np.savetxt(&quot;my_array.csv&quot;, a, delimiter=&quot;,&quot;) . 이 파일을 로드하려면 loadtxt 함수를 사용합니다: . a_loaded = np.loadtxt(&quot;my_array.csv&quot;, delimiter=&quot;,&quot;) a_loaded . array([[0.5435938 , 0.92886307, 0.01535158], [0.4157283 , 0.9102127 , 0.55129708]]) . &#50517;&#52629;&#46108; .npz &#54252;&#47607; . 여러 개의 배열을 압축된 한 파일로 저장하는 것도 가능합니다: . b = np.arange(24, dtype=np.uint8).reshape(2, 3, 4) b . array([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]], dtype=uint8) . np.savez(&quot;my_arrays&quot;, my_a=a, my_b=b) . 파일 내용을 확인해 보죠. .npz 파일 확장자가 자동으로 추가되었습니다. . with open(&quot;my_arrays.npz&quot;, &quot;rb&quot;) as f: content = f.read() repr(content)[:180] + &quot;[...]&quot; . &#39;b&#34;PK x03 x04 x14 x00 x00 x00 x00 x00 x00 x00! x00 x063 xcf xb9 xb0 x00 x00 x00 xb0 x00 x00 x00 x08 x00 x14 x00my_a.npy x01 x00 x10 x00 xb0 x00 x00 x00 x00 x00 x00 x00 xb0 x00 x00 x[...]&#39; . 다음과 같이 이 파일을 로드할 수 있습니다: . my_arrays = np.load(&quot;my_arrays.npz&quot;) my_arrays . &lt;numpy.lib.npyio.NpzFile at 0x7f9791c73d60&gt; . 게으른 로딩을 수행하는 딕셔너리와 유사한 객체입니다: . my_arrays.keys() . KeysView(&lt;numpy.lib.npyio.NpzFile object at 0x7f9791c73d60&gt;) . my_arrays[&quot;my_a&quot;] . array([[0.5435938 , 0.92886307, 0.01535158], [0.4157283 , 0.9102127 , 0.55129708]]) . &#44536; &#45796;&#51020;&#51008;? . 넘파이 기본 요소를 모두 배웠지만 훨씬 더 많은 기능이 있습니다. 이를 배우는 가장 좋은 방법은 넘파이를 직접 실습해 보고 훌륭한 넘파이 문서에서 필요한 함수와 기능을 찾아 보세요. .",
            "url": "https://jh20202792.github.io/JH_20202792/jupyter/python/2022/05/12/_03_04_numpy.html",
            "relUrl": "/jupyter/python/2022/05/12/_03_04_numpy.html",
            "date": " • May 12, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "Python_basics",
            "content": "from google.colab import drive drive.mount(&#39;/content/drive&#39;) . Mounted at /content/drive . Python Language Basics . Language Semantics . for x in array: if x &lt; pivot: less.append(x) else: greater.append(x) . a = [1,2,3] b = a a.append(4) b . [1, 2, 3, 4] . a . [1, 2, 3, 4] . &#45936;&#51060;&#53552; &#53440;&#51077; . a = 5 # 정수 type(a) . int . a = &#39;foo&#39; # 문자 type(a) . str . a = 4.5 # 소수 type(a) . float . &#39;5&#39; + 5 # 문자형과 숫자는 계산이 안 됨 . TypeError Traceback (most recent call last) &lt;ipython-input-15-a731f2591f02&gt; in &lt;module&gt;() -&gt; 1 &#39;5&#39; + 5.4 # 문자형과 숫자는 계산이 안 됨 TypeError: can only concatenate str (not &#34;float&#34;) to str . a = &#39;foo&#39; # a.&lt;Press Tab&gt; . a.capitalize() # 첫글자 대문자 . &#39;Foo&#39; . a.upper() # 모든 글자 대문자 . &#39;FOO&#39; . ★중요☆ . module&#9312; . PI = 3.14159 def f(x): return x + 2 def g(a, b): return a + b . import some_module result = some_module.f(5) result . pi = some_module.PI pi . module&#9313; . from some_module import f, g, PI result = g(5, PI) result . module&#9314; . import some_module as sm from some_module import PI as pi, g as gf r1 = sm.f(pi) r2 = gf(6, pi) . None . a = None # (R에서는 NULL) a is None . True . None &#54876;&#50857; . def add_and_maybe_multiply(a, b, c=None): # 더하기인데 어쩌면 곱하기까지 해준다 result = a + b if c is not None: result = result * c return result . add_and_maybe_multiply(5,3) . 8 . add_and_maybe_multiply(5,3,10) . 80 . &#48320;&#44221; &#44032;&#45733; &#50668;&#48512; objects . a_list = [&#39;foo&#39;, 2, [4, 5]] a_list[2] = (3, 4) a_list . [&#39;foo&#39;, 2, (3, 4)] . a_tuple = (3, 5, (4, 5)) a_tuple[1] = &#39;four&#39; . TypeError Traceback (most recent call last) &lt;ipython-input-30-15b6f95bd2d9&gt; in &lt;module&gt;() 1 # 변경 불가능 2 a_tuple = (3, 5, (4, 5)) -&gt; 3 a_tuple[1] = &#39;four&#39; TypeError: &#39;tuple&#39; object does not support item assignment . Strings . a = &#39;one way of writing a string&#39; b = &quot;another way&quot; . c = &quot;&quot;&quot; This is a longer string that spans multiple lines &quot;&quot;&quot; c . &#39; nThis is a longer string that nspans multiple lines n&#39; . c.count(&#39; n&#39;) . 3 . a = &#39;this is a string&#39; a[10] = &#39;f&#39; . TypeError Traceback (most recent call last) &lt;ipython-input-35-36daac36652b&gt; in &lt;module&gt;() 1 # strings 또한 바꿀 수 없음 2 a = &#39;this is a string&#39; -&gt; 3 a[10] = &#39;f&#39; TypeError: &#39;str&#39; object does not support item assignment . b = a.replace(&#39;string&#39;, &#39;longer string&#39;) b . &#39;this is a longer string&#39; . a = 5.6 s = str(a) print(s) . 5.6 . s = &#39;python&#39; list(s) . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . s[:3] . &#39;pyt&#39; . &#47928;&#51088; &#54633;&#52824;&#44592; . a = &#39;this is the first half&#39; b = &#39;and this is the second half&#39; a + b . &#39;this is the first halfand this is the second half&#39; . file_dir = &#39;G:/tmp&#39; file_name = &#39;test.csv&#39; file_dir + file_name . &#39;G:/tmptest.csv&#39; . string objects&#45716; format method &#44032;&#51648;&#44256; &#51080;&#51020; . template = &#39;{0:.2f}{1:s} are worth US${2:d}&#39; template # .2f : 소수점 둘째자리까지 # s : string # d : 정수형 . &#39;{0:.2f}{1:s} are worth US${2:d}&#39; . template.format(4.5560, &#39;Argentine Pasos&#39;, 1) . &#39;4.56Argentine Pasos are worth US$1&#39; . template.format(1263.23, &#39;won&#39;, 1) . &#39;1263.23won are worth US$1&#39; . &#45216;&#51676;&#50752; &#49884;&#44036; . from datetime import datetime, date, time dt = datetime(2011, 10, 29, 20, 30, 21) dt . datetime.datetime(2011, 10, 29, 20, 30, 21) . dt.day . 29 . dt.minute . 30 . dt.date() . datetime.date(2011, 10, 29) . dt.time() . datetime.time(20, 30, 21) . dt.strftime(&#39;%m/%d/%Y %H:%M&#39;) . &#39;10/29/2011 20:30&#39; . dt.strftime(&#39;%Y/%m/%d %H:%M&#39;) . &#39;2011/10/29 20:30&#39; . datetime.strptime(&#39;20091031&#39;, &#39;%Y%m%d&#39;) . datetime.datetime(2009, 10, 31, 0, 0) . dt.replace(minute=0, second=0) . datetime.datetime(2011, 10, 29, 20, 0) . dt2 = datetime(2011, 11, 15, 22, 30) de1ta = dt2 - dt de1ta . datetime.timedelta(days=17, seconds=7179) . type(de1ta) . datetime.timedelta . dt dt + de1ta . datetime.datetime(2011, 11, 15, 22, 30) . if, elif, and else . x = -5 if x &lt; 0: print(&#39;It is negative&#39;) . It is negative . x = -5 if x &lt; 0: print(&#39;It is negative&#39;) elif x == 0: print(&#39;Equal to zero&#39;) elif 0 &lt; x &lt; 5: print(&#39;Positive but smaller than 5&#39;) else: print(&#39;Positive and larger than or equal to 5&#39;) . It is negative . a = 5; b = 7 c = 8; d = 4 if a &lt; b or c &gt; d: print(&#39;Mage it&#39;) . Mage it . 4 &gt; 3 &gt; 2 &gt; 1 . True . 3&gt;5 or 2&gt;1 . True . 3&gt;5&gt;2&gt;1 . False . for loops . sequence = [1, 2, None, 4, None, 5] total = 0 for value in sequence: total += value . TypeError Traceback (most recent call last) &lt;ipython-input-53-76333c336dbd&gt; in &lt;module&gt;() 3 4 for value in sequence: -&gt; 5 total += value TypeError: unsupported operand type(s) for +=: &#39;int&#39; and &#39;NoneType&#39; . sequence = [1, 2, None, 4, None, 5] total = 0 for value in sequence: if value is None: continue total += value . total . 12 . sequence = [1, 2, 0, 4, 6, 5, 2, 1] total_until_5 = 0 for value in sequence: if value == 5: break total_until_5 += value . total_until_5 . 13 . for i in range(4): for j in range(4): if j &gt; i: break print((i, j)) . (0, 0) (1, 0) (1, 1) (2, 0) (2, 1) (2, 2) (3, 0) (3, 1) (3, 2) (3, 3) . for a, b, c in [[1,2,3],[4,5,6],[7,8,9]]: print(a,b,c) . 1 2 3 4 5 6 7 8 9 . while . x = 256 total = 0 while x &gt; 0: if total &gt; 500: break total += x x = x // 2 . total . 504 . x . 4 . 256+128+64+32+16+8 . 504 . pass - (if-else&#47928;&#50640;&#49436; &#49324;&#50857;) . (for문에서 사용하는 continue와 비슷) . x=-1 if x &lt; 0: print(&#39;negative!&#39;) elif x==0: # TODO: put something smart here pass else: print(&#39;positive!&#39;) . negative! .",
            "url": "https://jh20202792.github.io/JH_20202792/jupyter/python/2022/03/22/Python.html",
            "relUrl": "/jupyter/python/2022/03/22/Python.html",
            "date": " • Mar 22, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "Fastpages Notebook Blog Post",
            "content": "About . This notebook is a demonstration of some of capabilities of fastpages with notebooks. . With fastpages you can save your jupyter notebooks into the _notebooks folder at the root of your repository, and they will be automatically be converted to Jekyll compliant blog posts! . Front Matter . The first cell in your Jupyter Notebook or markdown blog post contains front matter. Front matter is metadata that can turn on/off options in your Notebook. It is formatted like this: . # &quot;My Title&quot; &gt; &quot;Awesome summary&quot; - toc:true- branch: master - badges: true - comments: true - author: Hamel Husain &amp; Jeremy Howard - categories: [fastpages, jupyter] . Setting toc: true will automatically generate a table of contents | Setting badges: true will automatically include GitHub and Google Colab links to your notebook. | Setting comments: true will enable commenting on your blog post, powered by utterances. | . The title and description need to be enclosed in double quotes only if they include special characters such as a colon. More details and options for front matter can be viewed on the front matter section of the README. . Markdown Shortcuts . A #hide comment at the top of any code cell will hide both the input and output of that cell in your blog post. . A #hide_input comment at the top of any code cell will only hide the input of that cell. . The comment #hide_input was used to hide the code that produced this. . put a #collapse-hide flag at the top of any cell if you want to hide that cell by default, but give the reader the option to show it: . import pandas as pd import altair as alt . . put a #collapse-show flag at the top of any cell if you want to show that cell by default, but give the reader the option to hide it: . cars = &#39;https://vega.github.io/vega-datasets/data/cars.json&#39; movies = &#39;https://vega.github.io/vega-datasets/data/movies.json&#39; sp500 = &#39;https://vega.github.io/vega-datasets/data/sp500.csv&#39; stocks = &#39;https://vega.github.io/vega-datasets/data/stocks.csv&#39; flights = &#39;https://vega.github.io/vega-datasets/data/flights-5k.json&#39; . . place a #collapse-output flag at the top of any cell if you want to put the output under a collapsable element that is closed by default, but give the reader the option to open it: . print(&#39;The comment #collapse-output was used to collapse the output of this cell by default but you can expand it.&#39;) . The comment #collapse-output was used to collapse the output of this cell by default but you can expand it. . . Interactive Charts With Altair . Charts made with Altair remain interactive. Example charts taken from this repo, specifically this notebook. . Example 1: DropDown . # use specific hard-wired values as the initial selected values selection = alt.selection_single( name=&#39;Select&#39;, fields=[&#39;Major_Genre&#39;, &#39;MPAA_Rating&#39;], init={&#39;Major_Genre&#39;: &#39;Drama&#39;, &#39;MPAA_Rating&#39;: &#39;R&#39;}, bind={&#39;Major_Genre&#39;: alt.binding_select(options=genres), &#39;MPAA_Rating&#39;: alt.binding_radio(options=mpaa)} ) # scatter plot, modify opacity based on selection alt.Chart(df).mark_circle().add_selection( selection ).encode( x=&#39;Rotten_Tomatoes_Rating:Q&#39;, y=&#39;IMDB_Rating:Q&#39;, tooltip=&#39;Title:N&#39;, opacity=alt.condition(selection, alt.value(0.75), alt.value(0.05)) ) . Example 2: Tooltips . alt.Chart(df).mark_circle().add_selection( alt.selection_interval(bind=&#39;scales&#39;, encodings=[&#39;x&#39;]) ).encode( alt.X(&#39;Rotten_Tomatoes_Rating&#39;, type=&#39;quantitative&#39;), alt.Y(&#39;IMDB_Rating&#39;, type=&#39;quantitative&#39;, axis=alt.Axis(minExtent=30)), # y=alt.Y(&#39;IMDB_Rating:Q&#39;, ), # use min extent to stabilize axis title placement tooltip=[&#39;Title:N&#39;, &#39;Release_Date:N&#39;, &#39;IMDB_Rating:Q&#39;, &#39;Rotten_Tomatoes_Rating:Q&#39;] ).properties( width=500, height=400 ) . Example 3: More Tooltips . label = alt.selection_single( encodings=[&#39;x&#39;], # limit selection to x-axis value on=&#39;mouseover&#39;, # select on mouseover events nearest=True, # select data point nearest the cursor empty=&#39;none&#39; # empty selection includes no data points ) # define our base line chart of stock prices base = alt.Chart().mark_line().encode( alt.X(&#39;date:T&#39;), alt.Y(&#39;price:Q&#39;, scale=alt.Scale(type=&#39;log&#39;)), alt.Color(&#39;symbol:N&#39;) ) alt.layer( base, # base line chart # add a rule mark to serve as a guide line alt.Chart().mark_rule(color=&#39;#aaa&#39;).encode( x=&#39;date:T&#39; ).transform_filter(label), # add circle marks for selected time points, hide unselected points base.mark_circle().encode( opacity=alt.condition(label, alt.value(1), alt.value(0)) ).add_selection(label), # add white stroked text to provide a legible background for labels base.mark_text(align=&#39;left&#39;, dx=5, dy=-5, stroke=&#39;white&#39;, strokeWidth=2).encode( text=&#39;price:Q&#39; ).transform_filter(label), # add text labels for stock prices base.mark_text(align=&#39;left&#39;, dx=5, dy=-5).encode( text=&#39;price:Q&#39; ).transform_filter(label), data=stocks ).properties( width=500, height=400 ) . Data Tables . You can display tables per the usual way in your blog: . df[[&#39;Title&#39;, &#39;Worldwide_Gross&#39;, &#39;Production_Budget&#39;, &#39;Distributor&#39;, &#39;MPAA_Rating&#39;, &#39;IMDB_Rating&#39;, &#39;Rotten_Tomatoes_Rating&#39;]].head() . Title Worldwide_Gross Production_Budget Distributor MPAA_Rating IMDB_Rating Rotten_Tomatoes_Rating . 0 The Land Girls | 146083.0 | 8000000.0 | Gramercy | R | 6.1 | NaN | . 1 First Love, Last Rites | 10876.0 | 300000.0 | Strand | R | 6.9 | NaN | . 2 I Married a Strange Person | 203134.0 | 250000.0 | Lionsgate | None | 6.8 | NaN | . 3 Let&#39;s Talk About Sex | 373615.0 | 300000.0 | Fine Line | None | NaN | 13.0 | . 4 Slam | 1087521.0 | 1000000.0 | Trimark | R | 3.4 | 62.0 | . Images . Local Images . You can reference local images and they will be copied and rendered on your blog automatically. You can include these with the following markdown syntax: . ![](my_icons/fastai_logo.png) . . Remote Images . Remote images can be included with the following markdown syntax: . ![](https://image.flaticon.com/icons/svg/36/36686.svg) . . Animated Gifs . Animated Gifs work, too! . ![](https://upload.wikimedia.org/wikipedia/commons/7/71/ChessPawnSpecialMoves.gif) . . Captions . You can include captions with markdown images like this: . ![](https://www.fast.ai/images/fastai_paper/show_batch.png &quot;Credit: https://www.fast.ai/2020/02/13/fastai-A-Layered-API-for-Deep-Learning/&quot;) . . Other Elements . GitHub Flavored Emojis . Typing I give this post two :+1:! will render this: . I give this post two :+1:! . Tweetcards . Typing &gt; twitter: https://twitter.com/jakevdp/status/1204765621767901185?s=20 will render this: Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 . Youtube Videos . Typing &gt; youtube: https://youtu.be/XfoYk_Z5AkI will render this: . Boxes / Callouts . Typing &gt; Warning: There will be no second warning! will render this: . Warning: There will be no second warning! . Typing &gt; Important: Pay attention! It&#39;s important. will render this: . Important: Pay attention! It&#8217;s important. . Typing &gt; Tip: This is my tip. will render this: . Tip: This is my tip. . Typing &gt; Note: Take note of this. will render this: . Note: Take note of this. . Typing &gt; Note: A doc link to [an example website: fast.ai](https://www.fast.ai/) should also work fine. will render in the docs: . Note: A doc link to an example website: fast.ai should also work fine. . Footnotes . You can have footnotes in notebooks, however the syntax is different compared to markdown documents. This guide provides more detail about this syntax, which looks like this: . For example, here is a footnote {% fn 1 %}. And another {% fn 2 %} {{ &#39;This is the footnote.&#39; | fndetail: 1 }} {{ &#39;This is the other footnote. You can even have a [link](www.github.com)!&#39; | fndetail: 2 }} . For example, here is a footnote 1. . And another 2 . 1. This is the footnote.↩ . 2. This is the other footnote. You can even have a link!↩ .",
            "url": "https://jh20202792.github.io/JH_20202792/jupyter/2020/02/20/test.html",
            "relUrl": "/jupyter/2020/02/20/test.html",
            "date": " • Feb 20, 2020"
        }
        
    
  
    
        ,"post4": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://jh20202792.github.io/JH_20202792/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "about me . 안녕하세요. 윤지혜입니다 .",
          "url": "https://jh20202792.github.io/JH_20202792/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://jh20202792.github.io/JH_20202792/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}